<?xml version='1.0' standalone='yes'?>
<!DOCTYPE PLUGIN [
<!ENTITY name      "plex_to_cache">
<!ENTITY author    "MajorPain007">
<!ENTITY version   "2025.12.30.02">
<!ENTITY launch    "Utilities/plex_to_cache">
<!ENTITY pluginURL "https://raw.githubusercontent.com/MajorPain007/unraid-move-to-cache/main/plex_to_cache.plg">
]>
<PLUGIN name="&name;" author="&author;" version="&version;" launch="&launch;" pluginURL="&pluginURL;" icon="database">

<DESCRIPTION>
Automatically moves media from Unraid array to cache when a stream starts in Plex, Emby or Jellyfin. Includes smart cleanup, permission mirroring and season-ahead caching.
</DESCRIPTION>

<FILE Name="/usr/local/emhttp/plugins/&name;/log.php">
<INLINE>
<![CDATA[
<?php
$log_file = "/var/log/plex_to_cache.log";
if (file_exists($log_file)) {
    echo shell_exec("tail -n 200 " . escapeshellarg($log_file));
} else { echo "Waiting for service..."; }
?>
]]>
</INLINE>
</FILE>

<FILE Name="/usr/local/emhttp/plugins/&name;/plex_to_cache.page">
<INLINE>
<![CDATA[
Menu="Utilities"
Icon="database"
Title="Plex to Cache"
---
<?php include '/usr/local/emhttp/plugins/plex_to_cache/plex_to_cache.php'; ?>
]]>
</INLINE>
</FILE>

<FILE Name="/usr/local/emhttp/plugins/&name;/plex_to_cache.php">
<INLINE>
<![CDATA[
<?php
$ptc_plugin = "plex_to_cache";
$ptc_cfg_file = "/boot/config/plugins/$ptc_plugin/settings.cfg";

$ptc_cfg = [
    "LANGUAGE" => "DE",
    "ENABLE_PLEX" => "True", "PLEX_URL" => "http://192.168.20.3:32400", "PLEX_TOKEN" => "",
    "ENABLE_EMBY" => "False", "EMBY_URL" => "http://192.168.20.3:8097", "EMBY_API_KEY" => "",
    "ENABLE_JELLYFIN" => "False", "JELLYFIN_URL" => "http://192.168.20.3:8097", "JELLYFIN_API_KEY" => "",
    "CHECK_INTERVAL" => "10", "CACHE_MAX_USAGE" => "80", "COPY_DELAY" => "30",
    "ENABLE_SMART_CLEANUP" => "False", "MOVIE_DELETE_DELAY" => "1800", "EPISODE_KEEP_PREVIOUS" => "2",
    "EXCLUDE_DIRS" => "", "MEDIA_FILETYPES" => ".mkv .mp4 .avi", "ARRAY_ROOT" => "/mnt/user",
    "CACHE_ROOT" => "/mnt/cache", "DOCKER_MAPPINGS" => "/Media:/media"
];

if (file_exists($ptc_cfg_file)) {
    $ptc_loaded = parse_ini_file($ptc_cfg_file);
    if ($ptc_loaded) { $ptc_cfg = array_merge($ptc_cfg, $ptc_loaded); }
}

$lang = $ptc_cfg['LANGUAGE'] == 'EN' ? 'EN' : 'DE';
$txt = [
    'DE' => [
        'settings' => 'Einstellungen', 'save' => 'Speichern & Übernehmen', 'plex' => 'Plex Media Server',
        'emby' => 'Emby Server', 'jelly' => 'Jellyfin Server', 'enable' => 'Aktivieren:',
        'paths' => 'Pfad Konfiguration', 'mappings' => 'Docker Pfad Mappings', 'tuning' => 'Tuning & Cleanup',
        'interval' => 'Check Intervall:', 'delay' => 'Kopier Verzögerung:', 'max_cache' => 'Max Cache:',
        'smart' => 'Smart Cleanup:', 'del_delay' => 'Lösch Verzögerung:', 'keep' => 'Episoden behalten:',
        'host' => 'Host Path (Unraid)', 'docker' => 'Docker Path (Container)', 'log' => 'Log Auswertung',
        'lang' => 'Sprache / Language'
    ],
    'EN' => [
        'settings' => 'Settings', 'save' => 'Save & Apply', 'plex' => 'Plex Media Server',
        'emby' => 'Emby Server', 'jelly' => 'Jellyfin Server', 'enable' => 'Enable:',
        'paths' => 'Storage Paths', 'mappings' => 'Docker Path Mappings', 'tuning' => 'Tuning & Cleanup',
        'interval' => 'Check Interval:', 'delay' => 'Copy Delay:', 'max_cache' => 'Max Cache:',
        'smart' => 'Smart Cleanup:', 'del_delay' => 'Delete Delay:', 'keep' => 'Keep Episodes:',
        'host' => 'Host Path (Unraid)', 'docker' => 'Docker Path (Container)', 'log' => 'Log Output',
        'lang' => 'Language'
    ]
];

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    foreach ($ptc_cfg as $key => $val) {
        if (isset($_POST[$key])) { $ptc_cfg[$key] = $_POST[$key]; }
        else { if (strpos($key, "ENABLE_") === 0 || $key === "ENABLE_SMART_CLEANUP") { $ptc_cfg[$key] = "False"; } }
    }
    $m_str = "";
    if (isset($_POST['mapping_host']) && isset($_POST['mapping_docker'])) {
        $h_arr = $_POST['mapping_host']; $d_arr = $_POST['mapping_docker']; $pairs = [];
        for ($i=0; $i<count($h_arr); $i++) {
            if (!empty(trim($h_arr[$i]))) { $pairs[] = trim($h_arr[$i]).":".trim($d_arr[$i]); }
        }
        $m_str = implode(";", $pairs);
    }
    $ptc_cfg['DOCKER_MAPPINGS'] = $m_str;
    $content = "";
    foreach ($ptc_cfg as $key => $val) { $content .= "$key=\"$val\"\n"; }
    if (!is_dir(dirname($ptc_cfg_file))) mkdir(dirname($ptc_cfg_file), 0777, true);
    file_put_contents($ptc_cfg_file, $content);
    shell_exec("/usr/local/emhttp/plugins/plex_to_cache/scripts/rc.plex_to_cache restart");
    echo "<script>window.location.reload();</script>";
}

$mappings_pairs = [];
if (!empty($ptc_cfg['DOCKER_MAPPINGS'])) {
    $pairs = explode(";", $ptc_cfg['DOCKER_MAPPINGS']);
    foreach ($pairs as $p) { if (strpos($p, ":") !== false) { $mappings_pairs[] = explode(":", $p, 2); } }
}
?>
<style>
:root { --primary-blue: #00aaff; --bg-dark: #111; }
#ptc-wrapper { display: flex; flex-wrap: nowrap; align-items: flex-start; justify-content: space-between; gap: 20px; width: 100%; box-sizing: border-box; }
#ptc-settings, #ptc-log-container { background: var(--bg-dark); border-radius: 12px; box-shadow: 0 0 12px rgba(0, 170, 255, 0.2); color: #f0f8ff; padding: 20px; box-sizing: border-box; }
#ptc-settings { flex: 0 0 48%; }
#ptc-log-container { flex: 0 0 50%; display: flex; flex-direction: column; min-height: 850px; }
.section-header { color: var(--primary-blue); font-size: 18px; font-weight: bold; margin-bottom: 12px; margin-top: 20px; border-bottom: 1px solid #333; padding-bottom: 5px; }
.form-pair { display: flex; align-items: center; margin-bottom: 10px; gap: 10px; }
.form-pair label { flex: 0 0 140px; color: var(--primary-blue); font-weight: bold; font-size: 14px; }
.form-input-wrapper { flex: 1; display: flex; align-items: center; }
.form-input-wrapper input[type="text"], .form-input-wrapper input[type="password"], .form-input-wrapper input[type="number"], .form-input-wrapper select { background: #111; border: 1px solid var(--primary-blue); border-radius: 5px; color: #fff; padding: 8px; width: 100%; box-sizing: border-box; }
.form-input-wrapper input[type="checkbox"] { accent-color: var(--primary-blue); width: 18px; height: 18px; cursor: pointer; }
#ptc-log { background: #000; border: 1px solid var(--primary-blue); border-radius: 8px; color: #00ffaa; font-family: monospace; font-size: 12px; padding: 15px; flex-grow: 1; overflow-y: auto; white-space: pre-wrap; word-break: break-all; margin-top: 10px; }
</style>
<div id="ptc-wrapper">
    <div id="ptc-settings">
        <form method="post" autocomplete="off">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin:0; color:var(--primary-blue);"><?= $txt[$lang]['settings'] ?></h2>
                <input type="submit" value="<?= $txt[$lang]['save'] ?>" style="background:var(--primary-blue); color:#fff; border:none; padding:10px 20px; border-radius:4px; font-weight:bold; cursor:pointer;">
            </div>

            <div class="form-pair"><label><?= $txt[$lang]['lang'] ?>:</label>
                <div class="form-input-wrapper">
                    <select name="LANGUAGE" onchange="this.form.submit()">
                        <option value="DE" <?= $lang == 'DE' ? 'selected' : '' ?>>Deutsch</option>
                        <option value="EN" <?= $lang == 'EN' ? 'selected' : '' ?>>English</option>
                    </select>
                </div>
            </div>

            <div class="section-header"><?= $txt[$lang]['plex'] ?></div>
            <div class="form-pair"><label><?= $txt[$lang]['enable'] ?></label><div class="form-input-wrapper"><input type="checkbox" name="ENABLE_PLEX" value="True" <?= $ptc_cfg['ENABLE_PLEX'] == 'True' ? 'checked' : '' ?> ></div></div>
            <div class="form-pair"><label>URL:</label><div class="form-input-wrapper"><input type="text" name="PLEX_URL" value="<?= $ptc_cfg['PLEX_URL'] ?>" autocomplete="off"></div></div>
            <div class="form-pair"><label>Token:</label><div class="form-input-wrapper"><input type="password" name="PLEX_TOKEN" value="<?= $ptc_cfg['PLEX_TOKEN'] ?>" onmouseover="this.type='text'" onmouseout="this.type='password'" autocomplete="new-password"></div></div>
            
            <div class="section-header"><?= $txt[$lang]['emby'] ?></div>
            <div class="form-pair"><label><?= $txt[$lang]['enable'] ?></label><div class="form-input-wrapper"><input type="checkbox" name="ENABLE_EMBY" value="True" <?= $ptc_cfg['ENABLE_EMBY'] == 'True' ? 'checked' : '' ?> ></div></div>
            <div class="form-pair"><label>URL:</label><div class="form-input-wrapper"><input type="text" name="EMBY_URL" value="<?= $ptc_cfg['EMBY_URL'] ?>" autocomplete="off"></div></div>
            <div class="form-pair"><label>API Key:</label><div class="form-input-wrapper"><input type="password" name="EMBY_API_KEY" value="<?= $ptc_cfg['EMBY_API_KEY'] ?>" autocomplete="new-password"></div></div>
            
            <div class="section-header"><?= $txt[$lang]['jelly'] ?></div>
            <div class="form-pair"><label><?= $txt[$lang]['enable'] ?></label><div class="form-input-wrapper"><input type="checkbox" name="ENABLE_JELLYFIN" value="True" <?= $ptc_cfg['ENABLE_JELLYFIN'] == 'True' ? 'checked' : '' ?> ></div></div>
            <div class="form-pair"><label>URL:</label><div class="form-input-wrapper"><input type="text" name="JELLYFIN_URL" value="<?= $ptc_cfg['JELLYFIN_URL'] ?>" autocomplete="off"></div></div>
            <div class="form-pair"><label>API Key:</label><div class="form-input-wrapper"><input type="password" name="JELLYFIN_API_KEY" value="<?= $ptc_cfg['JELLYFIN_API_KEY'] ?>" autocomplete="new-password"></div></div>
            
            <div class="section-header"><?= $txt[$lang]['paths'] ?></div>
            <div class="form-pair"><label>Array Root:</label><div class="form-input-wrapper"><input type="text" name="ARRAY_ROOT" value="<?= $ptc_cfg['ARRAY_ROOT'] ?>"></div></div>
            <div class="form-pair"><label>Cache Root:</label><div class="form-input-wrapper"><input type="text" name="CACHE_ROOT" value="<?= $ptc_cfg['CACHE_ROOT'] ?>"></div></div>
            
            <div class="section-header"><?= $txt[$lang]['mappings'] ?></div>
            <table id="mapping_table" style="width:100%;"><thead><tr><th style="color:var(--primary-blue);text-align:left;"><?= $txt[$lang]['host'] ?></th><th style="color:var(--primary-blue);text-align:left;"><?= $txt[$lang]['docker'] ?></th><th></th></tr></thead><tbody></tbody></table>
            <button type="button" onclick="addMappingRow()" style="background:transparent; color:var(--primary-blue); border:1px solid var(--primary-blue); padding:5px 10px; border-radius:4px; cursor:pointer; margin-top:10px;">+ Mapping</button>
            
            <div class="section-header"><?= $txt[$lang]['tuning'] ?></div>
            <div class="form-pair"><label><?= $txt[$lang]['interval'] ?></label><div class="form-input-wrapper"><input type="number" name="CHECK_INTERVAL" value="<?= $ptc_cfg['CHECK_INTERVAL'] ?>" style="width: 80px;"><span style="margin-left:8px;font-style:italic;color:#888;">sek</span></div></div>
            <div class="form-pair"><label><?= $txt[$lang]['delay'] ?></label><div class="form-input-wrapper"><input type="number" name="COPY_DELAY" value="<?= $ptc_cfg['COPY_DELAY'] ?>" style="width: 80px;"><span style="margin-left:8px;font-style:italic;color:#888;">sek</span></div></div>
            <div class="form-pair"><label><?= $txt[$lang]['smart'] ?></label><div class="form-input-wrapper"><input type="checkbox" name="ENABLE_SMART_CLEANUP" value="True" <?= $ptc_cfg['ENABLE_SMART_CLEANUP'] == 'True' ? 'checked' : '' ?> ></div></div>
            <div class="form-pair"><label><?= $txt[$lang]['del_delay'] ?></label><div class="form-input-wrapper"><input type="number" name="MOVIE_DELETE_DELAY" value="<?= $ptc_cfg['MOVIE_DELETE_DELAY'] ?>" style="width: 80px;"><span style="margin-left:8px;font-style:italic;color:#888;">sek</span></div></div>
            <div class="form-pair"><label><?= $txt[$lang]['keep'] ?></label><div class="form-input-wrapper"><input type="number" name="EPISODE_KEEP_PREVIOUS" value="<?= $ptc_cfg['EPISODE_KEEP_PREVIOUS'] ?>" style="width: 80px;"></div></div>
        </form>
    </div>
    <div id="ptc-log-container">
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h3 style="margin:0; color:var(--primary-blue); font-size:18px; font-weight:bold;"><i class="fa fa-terminal"></i> <?= $txt[$lang]['log'] ?></h3>
            <div style="display:flex; align-items:center; gap:10px;">
                <label style="color:#888; font-size:12px; cursor:pointer;"><input type="checkbox" id="auto_refresh" checked> Auto Refresh</label>
                <button onclick="refreshLog();" style="background:transparent; color:var(--primary-blue); border:1px solid var(--primary-blue); padding:5px 10px; border-radius:4px; cursor:pointer;">Refresh</button>
            </div>
        </div>
        <div id="ptc-log">Loading Logs...</div>
    </div>
</div>
<script>
function refreshLog() {
    $.get('/plugins/plex_to_cache/log.php', function(data) {
        var logDiv = $('#ptc-log');
        logDiv.text(data);
        logDiv.scrollTop(logDiv[0].scrollHeight);
    });
}
function addMappingRow(hostVal = '', dockerVal = '') {
    var table = document.getElementById('mapping_table').getElementsByTagName('tbody')[0];
    var row = table.insertRow(-1);
    var c1 = row.insertCell(0); var c2 = row.insertCell(1); var c3 = row.insertCell(2);
    c1.innerHTML = '<input type="text" name="mapping_host[]" value="' + hostVal + '" style="width:100%; background:#111; border:1px solid var(--primary-blue); color:#fff; padding:6px; border-radius:4px;">';
    c2.innerHTML = '<input type="text" name="mapping_docker[]" value="' + dockerVal + '" style="width:100%; background:#111; border:1px solid var(--primary-blue); color:#fff; padding:6px; border-radius:4px;">';
    c3.innerHTML = '<a href="#" onclick="deleteRow(this); return false;" style="color:#ff4444; font-size:18px;"><i class="fa fa-minus-circle"></i></a>';
}
function deleteRow(btn) { var row = btn.parentNode.parentNode; row.parentNode.removeChild(row); }
$(function() {
    <?php foreach ($mappings_pairs as $p): ?> addMappingRow('<?= addslashes($p[0]) ?>', '<?= addslashes($p[1]) ?>'); <?php endforeach; ?>
    if (document.getElementById('mapping_table').rows.length <= 1) { addMappingRow(); }
    refreshLog();
    setInterval(function() { if ($('#auto_refresh').is(':checked')) refreshLog(); }, 3000);
});
</script>
]]>
</INLINE>
</FILE>

<FILE Name="/usr/local/emhttp/plugins/&name;/scripts/plex_to_cache.py">
<INLINE>
<![CDATA[
#!/usr/bin/python3
import requests, os, shutil, subprocess, time, sys, re, fcntl, signal
from pathlib import Path

# --- ORIGINAL CORE LOGIC (V2025.12.30.02) ---
CONFIG_FILE = "/boot/config/plugins/plex_to_cache/settings.cfg"
LOCK_FILE_PATH = "/tmp/media_cache_cleaner.lock"
PERMS_ROOT = "/mnt/user0" 

CONF, parsed_docker_mappings, stream_start_times, metadata_path_cache = {}, {}, {}, {}
movie_deletion_queue = {}

def log_info(msg):
    print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] {msg}", flush=True)

def load_plugin_config():
    global CONF, parsed_docker_mappings
    CONF = {
        "ENABLE_PLEX": "False", "PLEX_URL": "http://localhost:32400", "PLEX_TOKEN": "",
        "ENABLE_EMBY": "False", "EMBY_URL": "http://localhost:8096", "EMBY_API_KEY": "",
        "ENABLE_JELLYFIN": "False", "JELLYFIN_URL": "http://localhost:8096", "JELLYFIN_API_KEY": "",
        "CHECK_INTERVAL": "10", "CACHE_MAX_USAGE": "80", "COPY_DELAY": "30",
        "ENABLE_SMART_CLEANUP": "False", "MOVIE_DELETE_DELAY": "1800", "EPISODE_KEEP_PREVIOUS": "2",
        "EXCLUDE_DIRS": "", "MEDIA_FILETYPES": ".mkv .mp4 .avi", "ARRAY_ROOT": "/mnt/user",
        "CACHE_ROOT": "/mnt/cache", "DOCKER_MAPPINGS": ""
    }
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r') as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith("#") or "=" not in line: continue
                    k, v = line.split("=", 1)
                    CONF[k.strip()] = v.strip().strip('"').strip("'")
        except: pass
    
    parsed_docker_mappings.clear()
    m_str = CONF.get("DOCKER_MAPPINGS", "")
    if m_str:
        for pair in m_str.split(';'):
            if ':' in pair:
                hp, dp = pair.split(':', 1)
                parsed_docker_mappings[dp.strip()] = hp.strip()

def get_b(key): return CONF.get(key, "False").lower() in ["true", "1", "yes"]
def get_i(key):
    try: return int(CONF.get(key, 0))
    except: return 0

# --- RECHTE & STRUKTUR ---

def get_perms_reference_path(cache_path):
    CACHE_ROOT = CONF["CACHE_ROOT"]
    if cache_path.startswith(CACHE_ROOT):
        return cache_path.replace(CACHE_ROOT, PERMS_ROOT, 1)
    return None

def clone_rights_from_disk(dst_path):
    src_path = get_perms_reference_path(dst_path)
    if not src_path or not os.path.exists(src_path): return 
    try:
        st = os.stat(src_path)
        os.chown(dst_path, st.st_uid, st.st_gid)
        os.chmod(dst_path, st.st_mode)
    except Exception as e:
        log_info(f"[Perms Error] {e}")

def ensure_directory_structure_mirror(full_cache_file_path):
    CACHE_ROOT = CONF["CACHE_ROOT"]
    target_dir = os.path.dirname(full_cache_file_path)
    try: rel_path = os.path.relpath(target_dir, CACHE_ROOT)
    except: return 
    current_cache_path = CACHE_ROOT
    for part in rel_path.split(os.sep):
        if not part or part == ".": continue
        current_cache_path = os.path.join(current_cache_path, part)
        if not os.path.exists(current_cache_path):
            try: 
                os.mkdir(current_cache_path)
                clone_rights_from_disk(current_cache_path)
            except: pass

# --- CLEANUP LOGIK ---

def cleanup_empty_parent_dirs(path):
    parent_dir, CACHE_ROOT = os.path.dirname(path), CONF["CACHE_ROOT"]
    protected = [os.path.join(CACHE_ROOT, m.strip("/")) for m in parsed_docker_mappings.values()]
    while parent_dir.startswith(CACHE_ROOT) and len(parent_dir) > len(CACHE_ROOT):
        if parent_dir in protected: break
        try:
            os.rmdir(parent_dir); parent_dir = os.path.dirname(parent_dir)
        except OSError: break

def move_to_array(cache_path):
    CACHE_ROOT = CONF["CACHE_ROOT"]
    dest_path = os.path.join(PERMS_ROOT, cache_path.replace(CACHE_ROOT, "").lstrip("/"))
    log_info(f"[Mover] -> Array: {os.path.basename(cache_path)}")
    try:
        os.makedirs(os.path.dirname(dest_path), exist_ok=True)
        subprocess.run(["rsync", "-a", "--remove-source-files", cache_path, dest_path], check=True, stdout=subprocess.DEVNULL)
        cleanup_empty_parent_dirs(cache_path)
    except Exception as e: log_info(f"[Error] Mover: {e}")

def smart_manage_cache_file(cache_path, reason="Cleanup"):
    if not os.path.exists(cache_path): return
    rel_path = cache_path.replace(CONF["CACHE_ROOT"], "").lstrip("/")
    array_path = os.path.join(PERMS_ROOT, rel_path)
    if os.path.exists(array_path):
        if os.path.getsize(cache_path) == os.path.getsize(array_path):
            os.remove(cache_path); log_info(f"[{reason}] Gelöscht: {os.path.basename(cache_path)}")
            cleanup_empty_parent_dirs(cache_path)
    else: move_to_array(cache_path)

# --- MEDIA HANDLING ---

def plex_api_get(endpoint):
    headers = {'X-Plex-Token': CONF["PLEX_TOKEN"], 'Accept': 'application/json'}
    try:
        r = requests.get(f"{CONF['PLEX_URL']}{endpoint}", headers=headers, timeout=5, verify=False)
        return r.json()
    except: return None

def emby_api_get(endpoint, key, url):
    headers = {'X-Emby-Token': key, 'Accept': 'application/json'}
    try:
        r = requests.get(f"{url}{endpoint}", headers=headers, timeout=5, verify=False)
        return r.json()
    except: return None

def get_active_sessions():
    active = {}
    if get_b("ENABLE_PLEX"):
        data = plex_api_get("/status/sessions")
        if data and 'MediaContainer' in data and 'Metadata' in data['MediaContainer']:
            for item in data['MediaContainer']['Metadata']:
                rk = item.get('ratingKey')
                found = None
                if rk in metadata_path_cache: found = metadata_path_cache[rk]
                if not found and 'Media' in item:
                    for media in item['Media']:
                        for part in media.get('Part', []):
                            if part.get('file'): found = p['file']; break
                if not found and rk:
                    meta = plex_api_get(f"/library/metadata/{rk}")
                    if meta and 'MediaContainer' in meta and 'Metadata' in meta['MediaContainer']:
                        for m in meta['MediaContainer']['Metadata']:
                            for med in m.get('Media', []):
                                for p in med.get('Part', []):
                                    if p.get('file'): found = p['file']; break
                if found: metadata_path_cache[rk] = found; active[found] = {'service': 'plex', 'id': rk}
    
    for svc in [("ENABLE_EMBY", "EMBY_API_KEY", "EMBY_URL", "emby"), ("ENABLE_JELLYFIN", "JELLYFIN_API_KEY", "JELLYFIN_URL", "jellyfin")]:
        if get_b(svc[0]):
            data = emby_api_get("/Sessions", CONF[svc[1]], CONF[svc[2]])
            if data:
                for s in data:
                    p = s.get('NowPlayingItem', {}).get('Path')
                    if p: active[p] = {'service': svc[3], 'id': s['NowPlayingItem'].get('Id'), 'user': s.get('UserId')}
    return active

def check_is_watched(session_data):
    if not session_data: return False
    service = session_data.get('service')
    if service == 'plex':
        rk = session_data.get('id')
        data = plex_api_get(f"/library/metadata/{rk}")
        if data and 'MediaContainer' in data and 'Metadata' in data['MediaContainer']:
            meta = data['MediaContainer']['Metadata'][0]
            if 'viewCount' in meta and meta['viewCount'] > 0: return True
    elif service in ['emby', 'jellyfin']:
        item_id, user_id = session_data.get('id'), session_data.get('user')
        url = CONF["EMBY_URL"] if service == 'emby' else CONF["JELLYFIN_URL"]
        key = CONF["EMBY_API_KEY"] if service == 'emby' else CONF["JELLYFIN_API_KEY"]
        if item_id and user_id:
            data = emby_api_get(f"/Users/{user_id}/Items/{item_id}", key, url)
            if data and 'UserData' in data: return data['UserData'].get('Played', False)
    return False

def translate_path(docker_path):
    clean = docker_path.replace('\\', '/')
    ARRAY_ROOT = CONF["ARRAY_ROOT"]
    for dp, hp in parsed_docker_mappings.items():
        if clean.startswith(dp):
            rel = clean[len(dp):].lstrip('/')
            if hp.startswith(ARRAY_ROOT): return os.path.join(hp, rel).replace('//', '/')
            else: return os.path.join(ARRAY_ROOT, hp.lstrip('/'), rel).replace('//', '/')
    return clean

def parse_episode_number(filename):
    match = re.search(r"[sS]\d+[eE](\d+)", filename)
    return int(match.group(1)) if match else None

def cache_file_if_needed(source_path):
    rel_path = source_path.replace(CONF["ARRAY_ROOT"], "").lstrip("/")
    if not rel_path: return
    dest_path = os.path.join(CONF["CACHE_ROOT"], rel_path)
    if os.path.exists(dest_path) and os.path.getsize(source_path) == os.path.getsize(dest_path):
        if dest_path in movie_deletion_queue: del movie_deletion_queue[dest_path]
        return
    log_info(f"[Copy] -> {os.path.basename(source_path)}")
    try:
        ensure_directory_structure_mirror(dest_path)
        subprocess.run(["rsync", "-a", source_path, dest_path], check=True, stdout=subprocess.DEVNULL)
        clone_rights_from_disk(dest_path)
    except Exception as e: log_info(f"[Error] Copy: {e}")

def handle_series_logic_smart(playing_real_path):
    filename = os.path.basename(playing_real_path)
    current_ep = parse_episode_number(filename)
    if current_ep is None: return handle_movie_logic(playing_real_path)
    season_dir_array = os.path.dirname(playing_real_path)
    season_dir_cache = os.path.join(CONF["CACHE_ROOT"], season_dir_array.replace(CONF["ARRAY_ROOT"], "").lstrip("/"))
    if get_b("ENABLE_SMART_CLEANUP") and os.path.exists(season_dir_cache):
        threshold_ep = current_ep - get_i("EPISODE_KEEP_PREVIOUS")
        for f in os.listdir(season_dir_cache):
            ep_num = parse_episode_number(f)
            if ep_num is not None and ep_num < threshold_ep:
                smart_manage_cache_file(os.path.join(season_dir_cache, f), reason="Smart Cleanup")
    try:
        if os.path.exists(season_dir_array):
            for f in sorted(os.listdir(season_dir_array)):
                ep_num = parse_episode_number(f)
                if ep_num is not None and ep_num >= current_ep: cache_file_if_needed(os.path.join(season_dir_array, f))
    except: pass

def handle_movie_logic(movie_real_path):
    cache_file_if_needed(movie_real_path)
    try:
        folder, stem = os.path.dirname(movie_real_path), os.path.splitext(os.path.basename(movie_real_path))[0]
        if os.path.exists(folder):
            for f in os.listdir(folder):
                if f.startswith(stem): cache_file_if_needed(os.path.join(folder, f))
    except: pass

def handle_movie_cleanup_smart(active_paths):
    if not get_b("ENABLE_SMART_CLEANUP"): return
    current_time = time.time()
    for movie in active_paths:
        rel = movie.replace(CONF["ARRAY_ROOT"], "").lstrip("/")
        c_path = os.path.join(CONF["CACHE_ROOT"], rel)
        if c_path in movie_deletion_queue: del movie_deletion_queue[c_path]
    for cache_path, timestamp in list(movie_deletion_queue.items()):
        if current_time - timestamp > get_i("MOVIE_DELETE_DELAY"):
            smart_manage_cache_file(cache_path, reason="Deletion Timer")
            del movie_deletion_queue[cache_path]

if __name__ == "__main__":
    lock_file = open(LOCK_FILE_PATH, 'w')
    try: fcntl.lockf(lock_file, fcntl.LOCK_EX | fcntl.LOCK_NB)
    except: sys.exit(0)
    load_plugin_config()
    signal.signal(signal.SIGHUP, lambda s, f: load_plugin_config())
    log_info("Dienst gestartet. Warte auf Streams...")
    if get_b("ENABLE_PLEX"):
        log_info(f"Plex Check: {CONF['PLEX_URL']}")
        if plex_api_get("/identity"): log_info("-> Plex OK")
        else: log_info("-> Plex Fehler!")
    
    last_loop_sessions = {}
    while True:
        try:
            current_sessions = get_active_sessions()
            active_real_paths = []
            for dp, s_data in current_sessions.items():
                rp = translate_path(dp)
                if not rp.startswith(CONF["ARRAY_ROOT"]): continue
                active_real_paths.append(rp)
                if rp not in stream_start_times:
                    log_info(f"[Stream] Aktiv: {os.path.basename(rp)}")
                    stream_start_times[rp] = time.time(); continue 
                if time.time() - stream_start_times[rp] >= get_i("COPY_DELAY"):
                    if parse_episode_number(os.path.basename(rp)) is not None: handle_series_logic_smart(rp)
                    else: handle_movie_logic(rp) 
            for path in list(stream_start_times.keys()):
                if path not in set(active_real_paths): del stream_start_times[path]
            if get_b("ENABLE_SMART_CLEANUP"):
                stopped = set(last_loop_sessions.keys()) - set(current_sessions.keys())
                for d_path in stopped:
                    s_data, rp = last_loop_sessions[d_path], translate_path(d_path)
                    if check_is_watched(s_data):
                        rel = rp.replace(CONF["ARRAY_ROOT"], "").lstrip("/")
                        c_path = os.path.join(CONF["CACHE_ROOT"], rel)
                        if os.path.exists(c_path): movie_deletion_queue[c_path] = time.time()
                handle_movie_cleanup_smart(active_real_paths)
            last_loop_sessions = current_sessions
        except Exception as e: log_info(f"[Error] Loop: {e}")
        time.sleep(get_i("CHECK_INTERVAL"))
]]>
</INLINE>
</FILE>

<FILE Name="/usr/local/emhttp/plugins/&name;/scripts/rc.plex_to_cache">
<INLINE>
<![CDATA[
#!/bin/bash
PYTHON_SCRIPT="/usr/local/emhttp/plugins/plex_to_cache/scripts/plex_to_cache.py"
PID_FILE="/var/run/plex_to_cache.pid"
LOG_FILE="/var/log/plex_to_cache.log"
start() {
    if [ -f "$PID_FILE" ] && ps -p $(cat "$PID_FILE") > /dev/null; then return; fi
    touch "$LOG_FILE" && chmod 666 "$LOG_FILE"
    nohup python3 "$PYTHON_SCRIPT" >> "$LOG_FILE" 2>&1 &
    echo $! > "$PID_FILE"
}
stop() {
    if [ -f "$PID_FILE" ]; then kill -9 $(cat "$PID_FILE") 2>/dev/null; rm "$PID_FILE"; fi
    pkill -f plex_to_cache.py 2>/dev/null
}
case "$1" in
    start) start ;; 
    stop) stop ;; 
    restart) stop; sleep 2; start ;; 
esac
]]>
</INLINE>
</FILE>

<FILE Run="/bin/bash">
<INLINE>
<![CDATA[
# Dependencies using the requested curl method
if ! python3 -c "import requests" 2>/dev/null; then
    curl -s https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py
    python3 /tmp/get-pip.py >/dev/null 2>&1
    pip3 install requests >/dev/null 2>&1
fi

pkill -9 -f plex_to_cache.py 2>/dev/null
rm -rf /usr/local/emhttp/plugins/plex_to_cache
chmod +x /usr/local/emhttp/plugins/plex_to_cache/scripts/rc.plex_to_cache
chmod +x /usr/local/emhttp/plugins/plex_to_cache/scripts/plex_to_cache.py
mkdir -p /boot/config/plugins/plex_to_cache
touch /var/log/plex_to_cache.log
chmod 666 /var/log/plex_to_cache.log
/usr/local/emhttp/plugins/plex_to_cache/scripts/rc.plex_to_cache restart
echo "Update v2025.12.30.02 installiert."
]]>
</INLINE>
</FILE>

</PLUGIN>