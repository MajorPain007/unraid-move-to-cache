<?xml version='1.0' standalone='yes'?>
<!DOCTYPE PLUGIN [
<!ENTITY name      "plex_to_cache">
<!ENTITY author    "MajorPain007">
<!ENTITY version   "2026.01.30e">
<!ENTITY launch    "Utilities/plex_to_cache">
<!ENTITY pluginURL "https://raw.githubusercontent.com/MajorPain007/unraid-move-to-cache/main/plex_to_cache.plg">
]>
<PLUGIN name="&name;" author="&author;" version="&version;" launch="&launch;" pluginURL="&pluginURL;" icon="server">

<DESCRIPTION>
Plex to Cache: Automatically moves media from array to cache on stream start. Includes smart cleanup, permission mirroring and season-ahead caching for Plex, Emby and Jellyfin.
</DESCRIPTION>

<CHANGES>
### 2026.01.30e
- Fixed: Plugin update now properly overwrites old files (no reinstall needed)
- Removed: Restart button (less cluttered UI)
- Changed: Reduced gap between columns (12px instead of 20px)
- Changed: Adjusted column widths for better balance

### 2026.01.30d
- Fixed: Test button now properly validates connections using curl with HTTP status codes
- Fixed: Grid layout - settings columns narrower, log column wider (2fr)
- Fixed: UI shows proper error messages (No Token, 401 Unauthorized, Connection error)

### 2026.01.30c
- Added: "Move ALL to Array" button - moves all cache files including plugin-cached media
- Added: "Move Cached Media to Array" button (renamed from Clear Cache)
- Changed: All move operations now check /mnt/user0 before deleting (safety check)
- Changed: Start/Stop/Restart buttons moved to same row as Save button
- Changed: Settings columns narrower, Log column wider for better readability
- Fixed: Files are moved to array instead of deleted when possible

### 2026.01.30b
- Added: Cleanup mode selector (None / Smart / Days-based)
- Added: Days-based cleanup - automatically moves files after X days
- Changed: Smart cleanup and days-based cleanup are mutually exclusive
- Note: Files now track when they were cached for days-based cleanup

### 2026.01.30a
- Added: File tracking system for cached media
- Added: "Move Other Files to Array" button (moves all non-plugin files to array)
- Added: Tracked files counter in UI
- Changed: Clear cache now only removes plugin-cached files

### 2026.01.30
- Added: Service status indicator with Start/Stop/Restart buttons
- Added: Connection test buttons for all media servers
- Added: Clear cache button to remove all cached media
- Changed: All text now in English
- Changed: Integrated log endpoint into main PHP file
- Fixed: SSL warnings are now suppressed
- Fixed: Errors are now logged instead of silently ignored

### 2025.12.31.12
- Fix: Settings are no longer deleted during update/uninstall (Safe Update)
- UI: Finalized CSS Grid Layout (25/25/50 split)

### 2025.12.31.11
- UI: New Layout Ratio (25% Server / 25% Tuning / 50% Log)
</CHANGES>

<FILE Run="/bin/bash">
<INLINE>
<![CDATA[
# Stop service
if [ -f /var/run/plex_to_cache.pid ]; then
    kill $(cat /var/run/plex_to_cache.pid) 2>/dev/null
    rm /var/run/plex_to_cache.pid
fi
pkill -f plex_to_cache.py 2>/dev/null

# Remove old plugin files (force update)
rm -f /usr/local/emhttp/plugins/plex_to_cache/plex_to_cache.php
rm -f /usr/local/emhttp/plugins/plex_to_cache/plex_to_cache.page
rm -f /usr/local/emhttp/plugins/plex_to_cache/scripts/plex_to_cache.py
rm -f /usr/local/emhttp/plugins/plex_to_cache/scripts/rc.plex_to_cache

# Create Directories
mkdir -p /usr/local/emhttp/plugins/plex_to_cache/scripts
mkdir -p /boot/config/plugins/plex_to_cache

# Check Python Requests
if ! python3 -c "import requests" 2>/dev/null; then
    echo "Installing Python Requests..."
    curl -s https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py
    python3 /tmp/get-pip.py >/dev/null 2>&1
    pip3 install requests >/dev/null 2>&1
fi
]]>
</INLINE>
</FILE>

<FILE Name="/usr/local/emhttp/plugins/plex_to_cache/plex_to_cache.page">
<INLINE>
<![CDATA[
Menu="Utilities"
Icon="server"
Title="Plex to Cache"
Description="Automatically moves viewed media from the array to the cache for faster streaming."
---
<?php include '/usr/local/emhttp/plugins/plex_to_cache/plex_to_cache.php'; ?>
]]>
</INLINE>
</FILE>

<FILE Name="/usr/local/emhttp/plugins/plex_to_cache/plex_to_cache.php">
<INLINE>
<![CDATA[
<?php
$ptc_plugin = "plex_to_cache";
$ptc_cfg_file = "/boot/config/plugins/$ptc_plugin/settings.cfg";
$ptc_log_file = "/var/log/plex_to_cache.log";
$ptc_pid_file = "/var/run/plex_to_cache.pid";
$ptc_tracked_file = "/boot/config/plugins/$ptc_plugin/cached_files.list";

// Defaults
$ptc_cfg = [
    "ENABLE_PLEX" => "False", "PLEX_URL" => "http://localhost:32400", "PLEX_TOKEN" => "",
    "ENABLE_EMBY" => "False", "EMBY_URL" => "http://localhost:8096", "EMBY_API_KEY" => "",
    "ENABLE_JELLYFIN" => "False", "JELLYFIN_URL" => "http://localhost:8096", "JELLYFIN_API_KEY" => "",
    "CHECK_INTERVAL" => "10", "CACHE_MAX_USAGE" => "80", "COPY_DELAY" => "30",
    "CLEANUP_MODE" => "none", "MOVIE_DELETE_DELAY" => "1800", "EPISODE_KEEP_PREVIOUS" => "2",
    "CACHE_MAX_DAYS" => "7", "EXCLUDE_DIRS" => "", "MEDIA_FILETYPES" => ".mkv .mp4 .avi",
    "ARRAY_ROOT" => "/mnt/user", "CACHE_ROOT" => "/mnt/cache", "DOCKER_MAPPINGS" => ""
];

if (file_exists($ptc_cfg_file)) {
    $ptc_loaded = parse_ini_file($ptc_cfg_file);
    if ($ptc_loaded) { $ptc_cfg = array_merge($ptc_cfg, $ptc_loaded); }
}

// AJAX: Get log
if (isset($_GET['action']) && $_GET['action'] === 'log') {
    header('Content-Type: text/plain');
    echo file_exists($ptc_log_file) ? shell_exec("tail -n 200 " . escapeshellarg($ptc_log_file)) : "Log file not found. Service might be starting...";
    exit;
}

// AJAX: Test connection
if (isset($_GET['action']) && $_GET['action'] === 'test') {
    header('Content-Type: application/json');
    $service = $_GET['service'] ?? '';
    $result = ['success' => false, 'message' => 'Unknown service'];

    if ($service === 'plex') {
        $url = rtrim($ptc_cfg['PLEX_URL'], '/') . '/';
        $token = $ptc_cfg['PLEX_TOKEN'];
        if (empty($token)) {
            $result = ['success' => false, 'message' => 'No Plex Token configured'];
        } else {
            $ch = curl_init($url);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_TIMEOUT => 5,
                CURLOPT_SSL_VERIFYPEER => false,
                CURLOPT_SSL_VERIFYHOST => false,
                CURLOPT_HTTPHEADER => ['X-Plex-Token: ' . $token, 'Accept: application/json']
            ]);
            $response = curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            $error = curl_error($ch);
            curl_close($ch);

            if ($httpCode === 200 && $response) {
                $data = json_decode($response, true);
                if (isset($data['MediaContainer'])) {
                    $name = $data['MediaContainer']['friendlyName'] ?? 'Plex Server';
                    $result = ['success' => true, 'message' => "Connected! Server: $name"];
                } else {
                    $result = ['success' => false, 'message' => 'Invalid response from Plex'];
                }
            } elseif ($httpCode === 401) {
                $result = ['success' => false, 'message' => 'Invalid Token (401 Unauthorized)'];
            } elseif ($error) {
                $result = ['success' => false, 'message' => "Connection error: $error"];
            } else {
                $result = ['success' => false, 'message' => "Connection failed (HTTP $httpCode)"];
            }
        }
    } elseif ($service === 'emby' || $service === 'jellyfin') {
        $url_key = $service === 'emby' ? 'EMBY_URL' : 'JELLYFIN_URL';
        $api_key_name = $service === 'emby' ? 'EMBY_API_KEY' : 'JELLYFIN_API_KEY';
        $api_key = $ptc_cfg[$api_key_name];
        $url = rtrim($ptc_cfg[$url_key], '/') . '/System/Info';

        if (empty($api_key)) {
            $result = ['success' => false, 'message' => 'No API Key configured'];
        } else {
            $ch = curl_init($url);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_TIMEOUT => 5,
                CURLOPT_SSL_VERIFYPEER => false,
                CURLOPT_SSL_VERIFYHOST => false,
                CURLOPT_HTTPHEADER => ['X-Emby-Token: ' . $api_key, 'Accept: application/json']
            ]);
            $response = curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            $error = curl_error($ch);
            curl_close($ch);

            if ($httpCode === 200 && $response) {
                $data = json_decode($response, true);
                if (isset($data['ServerName'])) {
                    $result = ['success' => true, 'message' => "Connected! Server: " . $data['ServerName']];
                } else {
                    $result = ['success' => false, 'message' => 'Invalid response from server'];
                }
            } elseif ($httpCode === 401) {
                $result = ['success' => false, 'message' => 'Invalid API Key (401 Unauthorized)'];
            } elseif ($error) {
                $result = ['success' => false, 'message' => "Connection error: $error"];
            } else {
                $result = ['success' => false, 'message' => "Connection failed (HTTP $httpCode)"];
            }
        }
    }
    echo json_encode($result);
    exit;
}

// AJAX: Clear all cached media (moves plugin-cached files back to array)
if (isset($_GET['action']) && $_GET['action'] === 'clearcache') {
    header('Content-Type: application/json');
    $count = 0;
    $size = 0;
    $cache_root = $ptc_cfg['CACHE_ROOT'];
    $array_root = '/mnt/user0'; // Physical disks

    // Load tracked files and move them to array
    if (file_exists($ptc_tracked_file)) {
        $lines = array_filter(array_map('trim', file($ptc_tracked_file)));
        foreach ($lines as $line) {
            // Format: path|timestamp - extract just the path
            $parts = explode('|', $line);
            $file = $parts[0];

            if (file_exists($file)) {
                $file_size = filesize($file);
                $rel = str_replace($cache_root, '', $file);
                $dst = $array_root . $rel;

                // Check if file already exists on array - then we can delete the cache copy
                if (file_exists($dst)) {
                    @unlink($file);
                    $size += $file_size;
                    $count++;
                } else {
                    // Move file to array using rsync
                    $dst_dir = dirname($dst);
                    if (!is_dir($dst_dir)) {
                        @mkdir($dst_dir, 0777, true);
                    }
                    $cmd = "rsync -a --remove-source-files " . escapeshellarg($file) . " " . escapeshellarg($dst) . " 2>&1";
                    exec($cmd, $output, $ret);
                    if ($ret === 0) {
                        $size += $file_size;
                        $count++;
                    }
                }
            }
        }
        // Clear the tracking file
        file_put_contents($ptc_tracked_file, '');
    }

    $size_mb = round($size / 1024 / 1024, 2);
    echo json_encode(['success' => true, 'message' => "Moved $count cached media files ({$size_mb} MB) to array"]);
    exit;
}

// AJAX: Move ALL files to array (including plugin-cached media)
if (isset($_GET['action']) && $_GET['action'] === 'moveall') {
    header('Content-Type: application/json');
    $cache_root = $ptc_cfg['CACHE_ROOT'];
    $array_root = '/mnt/user0'; // Physical disks
    $count = 0;
    $size = 0;

    if (is_dir($cache_root)) {
        $iterator = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($cache_root, RecursiveDirectoryIterator::SKIP_DOTS),
            RecursiveIteratorIterator::SELF_FIRST
        );

        $files_to_move = [];
        foreach ($iterator as $file) {
            if ($file->isFile()) {
                $files_to_move[] = $file->getPathname();
            }
        }

        foreach ($files_to_move as $src) {
            $rel = str_replace($cache_root, '', $src);
            $dst = $array_root . $rel;
            $dst_dir = dirname($dst);

            $file_size = filesize($src);

            // Check if file already exists on array - then we can delete the cache copy
            if (file_exists($dst)) {
                @unlink($src);
                $size += $file_size;
                $count++;
            } else {
                // Create destination directory if needed
                if (!is_dir($dst_dir)) {
                    @mkdir($dst_dir, 0777, true);
                }

                // Move file using rsync
                $cmd = "rsync -a --remove-source-files " . escapeshellarg($src) . " " . escapeshellarg($dst) . " 2>&1";
                exec($cmd, $output, $ret);
                if ($ret === 0) {
                    $size += $file_size;
                    $count++;
                }
            }
        }

        // Clean empty directories
        $dirs = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($cache_root, RecursiveDirectoryIterator::SKIP_DOTS),
            RecursiveIteratorIterator::CHILD_FIRST
        );
        foreach ($dirs as $dir) {
            if ($dir->isDir()) {
                @rmdir($dir->getPathname());
            }
        }
    }

    // Clear the tracking file since all files moved
    if (file_exists($ptc_tracked_file)) {
        file_put_contents($ptc_tracked_file, '');
    }

    $size_gb = round($size / 1024 / 1024 / 1024, 2);
    echo json_encode(['success' => true, 'message' => "Moved $count files ({$size_gb} GB) to array"]);
    exit;
}

// AJAX: Move other files to array (everything EXCEPT plugin-cached media)
if (isset($_GET['action']) && $_GET['action'] === 'moveother') {
    header('Content-Type: application/json');
    $cache_root = $ptc_cfg['CACHE_ROOT'];
    $array_root = '/mnt/user0'; // Physical disks
    $count = 0;
    $size = 0;

    // Load tracked files (files we want to KEEP on cache)
    $tracked = [];
    if (file_exists($ptc_tracked_file)) {
        $tracked = array_filter(array_map('trim', file($ptc_tracked_file)));
    }
    $tracked_set = array_flip($tracked);

    if (is_dir($cache_root)) {
        $iterator = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($cache_root, RecursiveDirectoryIterator::SKIP_DOTS),
            RecursiveIteratorIterator::SELF_FIRST
        );

        $files_to_move = [];
        foreach ($iterator as $file) {
            if ($file->isFile()) {
                $path = $file->getPathname();
                // Skip if this file is tracked (plugin-cached)
                if (isset($tracked_set[$path])) {
                    continue;
                }
                $files_to_move[] = $path;
            }
        }

        foreach ($files_to_move as $src) {
            $rel = str_replace($cache_root, '', $src);
            $dst = $array_root . $rel;
            $dst_dir = dirname($dst);

            $file_size = filesize($src);

            // Check if file already exists on array - then we can delete the cache copy
            if (file_exists($dst)) {
                @unlink($src);
                $size += $file_size;
                $count++;
            } else {
                // Create destination directory if needed
                if (!is_dir($dst_dir)) {
                    @mkdir($dst_dir, 0777, true);
                }

                // Move file using rsync
                $cmd = "rsync -a --remove-source-files " . escapeshellarg($src) . " " . escapeshellarg($dst) . " 2>&1";
                exec($cmd, $output, $ret);
                if ($ret === 0) {
                    $size += $file_size;
                    $count++;
                }
            }
        }

        // Clean empty directories
        $dirs = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($cache_root, RecursiveDirectoryIterator::SKIP_DOTS),
            RecursiveIteratorIterator::CHILD_FIRST
        );
        foreach ($dirs as $dir) {
            if ($dir->isDir()) {
                @rmdir($dir->getPathname());
            }
        }
    }

    $size_gb = round($size / 1024 / 1024 / 1024, 2);
    echo json_encode(['success' => true, 'message' => "Moved $count files ({$size_gb} GB) to array"]);
    exit;
}

// AJAX: Service control
if (isset($_GET['action']) && $_GET['action'] === 'service') {
    header('Content-Type: application/json');
    $cmd = $_GET['cmd'] ?? '';
    if (in_array($cmd, ['start', 'stop', 'restart'])) {
        shell_exec("/usr/local/emhttp/plugins/plex_to_cache/scripts/rc.plex_to_cache $cmd > /dev/null 2>&1");
        sleep(1);
        $running = file_exists($ptc_pid_file) && posix_kill((int)@file_get_contents($ptc_pid_file), 0);
        echo json_encode(['success' => true, 'running' => $running]);
    } else {
        echo json_encode(['success' => false, 'message' => 'Invalid command']);
    }
    exit;
}

// POST: Save settings
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    foreach ($ptc_cfg as $key => $val) {
        if (isset($_POST[$key])) { $ptc_cfg[$key] = $_POST[$key]; }
        else { if (strpos($key, "ENABLE_") === 0 || $key === "ENABLE_SMART_CLEANUP") { $ptc_cfg[$key] = "False"; } }
    }
    $m_str = "";
    if (isset($_POST['mapping_docker']) && isset($_POST['mapping_host'])) {
        $d_arr = $_POST['mapping_docker']; $h_arr = $_POST['mapping_host']; $pairs = [];
        for ($i=0; $i<count($d_arr); $i++) {
            if (!empty(trim($d_arr[$i])) && !empty(trim($h_arr[$i]))) { $pairs[] = trim($d_arr[$i]).":".trim($h_arr[$i]); }
        }
        $m_str = implode(";", $pairs);
    }
    $ptc_cfg['DOCKER_MAPPINGS'] = $m_str;

    $content = "";
    foreach ($ptc_cfg as $key => $val) { $content .= "$key=\"$val\"\n"; }

    if (!is_dir(dirname($ptc_cfg_file))) mkdir(dirname($ptc_cfg_file), 0777, true);
    file_put_contents($ptc_cfg_file, $content);

    shell_exec("/usr/local/emhttp/plugins/plex_to_cache/scripts/rc.plex_to_cache restart > /dev/null 2>&1 &");
    echo "<script>window.location.href = window.location.href;</script>";
    exit;
}

$mappings_pairs = [];
if (!empty($ptc_cfg['DOCKER_MAPPINGS'])) {
    $pairs = explode(";", $ptc_cfg['DOCKER_MAPPINGS']);
    foreach ($pairs as $p) { if (strpos($p, ":") !== false) { $mappings_pairs[] = explode(":", $p, 2); } }
}

// Check service status
$is_running = file_exists($ptc_pid_file) && posix_kill((int)@file_get_contents($ptc_pid_file), 0);

// Count tracked files
$tracked_count = 0;
if (file_exists($ptc_tracked_file)) {
    $tracked_count = count(array_filter(array_map('trim', file($ptc_tracked_file))));
}
?>
<style>
:root { --primary-blue: #00aaff; --bg-dark: #111; --success-green: #00cc66; --error-red: #ff4444; --warning-orange: #ff9900; }

#ptc-wrapper {
    display: grid;
    grid-template-columns: minmax(300px, 1fr) minmax(300px, 1fr) minmax(350px, 1.5fr);
    gap: 12px;
    align-items: stretch;
    width: 100%;
    box-sizing: border-box;
    padding: 10px 0;
}

@media (max-width: 1200px) {
    #ptc-wrapper {
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    }
}

.ptc-col {
    background: var(--bg-dark);
    border-radius: 8px;
    box-shadow: 0 0 10px rgba(0, 170, 255, 0.15);
    color: #f0f8ff;
    padding: 20px 20px 20px 20px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    min-height: 650px;
}

#ptc-col-log {
    display: flex;
    flex-direction: column;
}

#ptc-log {
    background: #000;
    border: 1px solid #333;
    border-radius: 8px;
    color: #00ffaa;
    font-family: 'Courier New', monospace;
    font-size: 13px;
    padding: 15px;
    margin-top: 10px;
    white-space: pre-wrap;
    word-break: break-all;
    flex-grow: 1;
    height: 0;
    min-height: 400px;
    overflow-y: auto;
}

/* Status indicator */
.status-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: bold;
    padding: 8px 12px;
    background: #1a1a1a;
    border-radius: 4px;
}

.status-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    animation: pulse 2s infinite;
}

.status-dot.running { background: var(--success-green); }
.status-dot.stopped { background: var(--error-red); animation: none; }

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

/* Top control bar with Save and Service buttons */
.top-control-bar {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    align-items: stretch;
}

.top-control-bar input[type="submit"],
.top-control-bar button {
    padding: 10px 16px;
    font-weight: bold;
    text-transform: uppercase;
    cursor: pointer;
    font-size: 13px;
    border-radius: 4px;
}

.top-control-bar input[type="submit"] {
    flex: 1;
}

.top-control-bar .service-btn {
    background: #222;
    border: 1px solid #444;
    color: #fff;
}

.top-control-bar .service-btn:hover {
    background: #333;
    border-color: var(--primary-blue);
}

/* Form elements */
.section-header { color: var(--primary-blue); font-size: 18px; font-weight: bold; margin-bottom: 15px; margin-top: 20px; border-bottom: 1px solid #333; padding-bottom: 5px; display: flex; align-items: center; gap: 8px; }
.section-header:first-of-type { margin-top: 0; }

.form-pair { display: flex; align-items: center; margin-bottom: 12px; gap: 10px; width: 100%; }
.form-pair label { flex: 0 0 100px; color: var(--primary-blue); font-weight: bold; font-size: 14px; position: relative; cursor: help; }
.form-input-wrapper { display: flex; align-items: center; gap: 8px; min-width: 0; flex: 1; }

.expand-row .form-input-wrapper { flex: 1; }
.expand-row input { width: 100% !important; max-width: none !important; box-sizing: border-box !important; }

/* Custom Tooltip */
.form-pair label:after {
    content: attr(data-tooltip);
    position: absolute;
    bottom: 130%;
    left: 0;
    background: #222;
    color: #fff;
    padding: 10px 14px;
    border-radius: 6px;
    font-size: 12.5px;
    font-weight: normal;
    width: 280px;
    z-index: 999;
    box-shadow: 0 5px 20px rgba(0,0,0,0.6);
    border: 1px solid var(--primary-blue);
    visibility: hidden;
    opacity: 0;
    pointer-events: none;
    white-space: normal;
    line-height: 1.5;
    text-transform: none;
}
.form-pair label:hover:after { visibility: visible; opacity: 1; transition: opacity 0.2s ease 0.5s; }

.ptc-input { background: #111 !important; border: 1px solid #444 !important; border-radius: 4px !important; color: #fff !important; padding: 6px 10px !important; font-size: 14px !important; height: 32px !important; width: 100% !important; max-width: none !important; box-sizing: border-box !important; }
.ptc-input:focus { border-color: var(--primary-blue) !important; outline: none !important; }
.input-small { width: 70px !important; flex: 0 0 70px !important; text-align: right; }
.form-input-wrapper input[type="checkbox"] { accent-color: var(--primary-blue); width: 18px; height: 18px; cursor: pointer; }
.unit-label { font-size: 12px; color: #777; white-space: nowrap; }

#mapping_table { width: 100%; border-collapse: collapse; margin-top: 10px; }
#mapping_table th { text-align: left; color: var(--primary-blue); padding: 8px; border-bottom: 1px solid #333; font-size: 13px; }
#mapping_table td { padding: 5px 0; }

/* Test button */
.btn-test {
    padding: 4px 10px;
    font-size: 11px;
    cursor: pointer;
    border: 1px solid #444;
    border-radius: 4px;
    background: #222;
    color: #fff;
    white-space: nowrap;
}
.btn-test:hover { background: #333; border-color: var(--primary-blue); }
.btn-test.success { border-color: var(--success-green); color: var(--success-green); }
.btn-test.error { border-color: var(--error-red); color: var(--error-red); }

/* Action buttons */
.btn-action {
    padding: 8px 16px;
    font-size: 12px;
    cursor: pointer;
    border-radius: 4px;
    background: transparent;
    margin-top: 10px;
    display: block;
    width: 100%;
    text-align: center;
}
.btn-action.danger {
    border: 1px solid var(--error-red);
    color: var(--error-red);
}
.btn-action.danger:hover { background: var(--error-red); color: #fff; }
.btn-action.warning {
    border: 1px solid var(--warning-orange);
    color: var(--warning-orange);
}
.btn-action.warning:hover { background: var(--warning-orange); color: #fff; }

.cache-info {
    font-size: 12px;
    color: #888;
    margin-top: 15px;
    padding: 10px;
    background: #1a1a1a;
    border-radius: 4px;
}
.cache-info strong { color: var(--primary-blue); }

/* Cleanup mode selector */
.cleanup-mode-selector {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 15px;
}
.radio-option {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 12px;
    background: #1a1a1a;
    border: 1px solid #333;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
}
.radio-option:hover { border-color: #555; }
.radio-option.selected { border-color: var(--primary-blue); background: #1a2a3a; }
.radio-option input[type="radio"] { accent-color: var(--primary-blue); width: 16px; height: 16px; margin: 0; }
.radio-label { color: #fff; font-weight: bold; font-size: 13px; min-width: 110px; }
.radio-desc { color: #888; font-size: 12px; }
.cleanup-options { margin-top: 10px; padding: 10px; background: #0a0a0a; border-radius: 6px; border: 1px solid #222; }
</style>

<form method="post" autocomplete="off">
    <div id="ptc-wrapper">
        <div class="ptc-col" id="ptc-col-servers">
            <div class="top-control-bar">
                <input type="submit" value="Save & Apply">
                <button type="button" class="service-btn" onclick="serviceControl('start')">Start</button>
                <button type="button" class="service-btn" onclick="serviceControl('stop')">Stop</button>
                <div class="status-indicator">
                    <span class="status-dot <?= $is_running ? 'running' : 'stopped' ?>" id="status-dot"></span>
                    <span id="status-text"><?= $is_running ? 'Running' : 'Stopped' ?></span>
                </div>
            </div>

            <div class="section-header"><i class="fa fa-play-circle"></i> Plex Server</div>
            <div class="form-pair"><label data-tooltip="Enables monitoring for Plex streams.">Enable:</label><div class="form-input-wrapper"><input type="checkbox" name="ENABLE_PLEX" value="True" <?= $ptc_cfg['ENABLE_PLEX'] == 'True' ? 'checked' : '' ?> ></div></div>
            <div class="form-pair expand-row"><label data-tooltip="The web address of your Plex server.">URL:</label><div class="form-input-wrapper"><input type="text" name="PLEX_URL" value="<?= htmlspecialchars($ptc_cfg['PLEX_URL']) ?>" class="ptc-input"></div></div>
            <div class="form-pair expand-row"><label data-tooltip="Your Plex Authentication Token.">Token:</label><div class="form-input-wrapper"><input type="password" name="PLEX_TOKEN" value="<?= htmlspecialchars($ptc_cfg['PLEX_TOKEN']) ?>" class="ptc-input" onmouseover="this.type='text'" onmouseout="this.type='password'" autocomplete="new-password"><button type="button" class="btn-test" onclick="testConnection('plex', this)">Test</button></div></div>

            <div class="section-header"><i class="fa fa-server"></i> Emby Server</div>
            <div class="form-pair"><label data-tooltip="Enables monitoring for Emby streams.">Enable:</label><div class="form-input-wrapper"><input type="checkbox" name="ENABLE_EMBY" value="True" <?= $ptc_cfg['ENABLE_EMBY'] == 'True' ? 'checked' : '' ?> ></div></div>
            <div class="form-pair expand-row"><label data-tooltip="The web address of your Emby server.">URL:</label><div class="form-input-wrapper"><input type="text" name="EMBY_URL" value="<?= htmlspecialchars($ptc_cfg['EMBY_URL']) ?>" class="ptc-input"></div></div>
            <div class="form-pair expand-row"><label data-tooltip="The API key for Emby.">API Key:</label><div class="form-input-wrapper"><input type="password" name="EMBY_API_KEY" value="<?= htmlspecialchars($ptc_cfg['EMBY_API_KEY']) ?>" class="ptc-input" onmouseover="this.type='text'" onmouseout="this.type='password'" autocomplete="new-password"><button type="button" class="btn-test" onclick="testConnection('emby', this)">Test</button></div></div>

            <div class="section-header"><i class="fa fa-film"></i> Jellyfin Server</div>
            <div class="form-pair"><label data-tooltip="Enables monitoring for Jellyfin streams.">Enable:</label><div class="form-input-wrapper"><input type="checkbox" name="ENABLE_JELLYFIN" value="True" <?= $ptc_cfg['ENABLE_JELLYFIN'] == 'True' ? 'checked' : '' ?> ></div></div>
            <div class="form-pair expand-row"><label data-tooltip="The web address of your Jellyfin server.">URL:</label><div class="form-input-wrapper"><input type="text" name="JELLYFIN_URL" value="<?= htmlspecialchars($ptc_cfg['JELLYFIN_URL']) ?>" class="ptc-input"></div></div>
            <div class="form-pair expand-row"><label data-tooltip="The API key for Jellyfin.">API Key:</label><div class="form-input-wrapper"><input type="password" name="JELLYFIN_API_KEY" value="<?= htmlspecialchars($ptc_cfg['JELLYFIN_API_KEY']) ?>" class="ptc-input" onmouseover="this.type='text'" onmouseout="this.type='password'" autocomplete="new-password"><button type="button" class="btn-test" onclick="testConnection('jellyfin', this)">Test</button></div></div>
        </div>

        <div class="ptc-col" id="ptc-col-tuning">
            <div class="section-header"><i class="fa fa-folder-open"></i> Storage Paths</div>
            <div class="form-pair expand-row"><label data-tooltip="The primary path of your Unraid array.">Array Root:</label><div class="form-input-wrapper"><input type="text" name="ARRAY_ROOT" value="<?= htmlspecialchars($ptc_cfg['ARRAY_ROOT']) ?>" class="ptc-input"></div></div>
            <div class="form-pair expand-row"><label data-tooltip="The path of your cache pool.">Cache Root:</label><div class="form-input-wrapper"><input type="text" name="CACHE_ROOT" value="<?= htmlspecialchars($ptc_cfg['CACHE_ROOT']) ?>" class="ptc-input"></div></div>
            <div class="form-pair expand-row"><label data-tooltip="Folder names to be ignored (comma-separated).">Exclude:</label><div class="form-input-wrapper"><input type="text" name="EXCLUDE_DIRS" value="<?= htmlspecialchars($ptc_cfg['EXCLUDE_DIRS']) ?>" placeholder="temp,downloads" class="ptc-input"></div></div>

            <div class="section-header"><i class="fa fa-exchange"></i> Docker Mappings</div>
            <table id="mapping_table"><thead><tr><th>Host Path</th><th>Docker Path</th><th></th></tr></thead><tbody></tbody></table>
            <button type="button" onclick="addMappingRow()" style="padding: 6px 12px; font-size: 12px; margin-top: 10px; cursor: pointer;">+ Add Mapping</button>

            <div class="section-header"><i class="fa fa-cogs"></i> Tuning</div>
            <div class="form-pair"><label data-tooltip="Interval in seconds to check for active streams.">Interval:</label><div class="form-input-wrapper"><input type="number" name="CHECK_INTERVAL" value="<?= htmlspecialchars($ptc_cfg['CHECK_INTERVAL']) ?>" class="ptc-input input-small"><span class="unit-label">sec</span></div></div>
            <div class="form-pair"><label data-tooltip="Delay before starting to copy files.">Copy Delay:</label><div class="form-input-wrapper"><input type="number" name="COPY_DELAY" value="<?= htmlspecialchars($ptc_cfg['COPY_DELAY']) ?>" class="ptc-input input-small"><span class="unit-label">sec</span></div></div>
            <div class="form-pair"><label data-tooltip="Maximum cache usage percentage before stopping copies.">Max Cache:</label><div class="form-input-wrapper"><input type="number" name="CACHE_MAX_USAGE" value="<?= htmlspecialchars($ptc_cfg['CACHE_MAX_USAGE']) ?>" class="ptc-input input-small"><span class="unit-label">%</span></div></div>

            <div class="section-header"><i class="fa fa-clock-o"></i> Auto Cleanup</div>
            <div class="cleanup-mode-selector">
                <label class="radio-option <?= $ptc_cfg['CLEANUP_MODE'] == 'none' ? 'selected' : '' ?>">
                    <input type="radio" name="CLEANUP_MODE" value="none" <?= $ptc_cfg['CLEANUP_MODE'] == 'none' ? 'checked' : '' ?> onchange="updateCleanupUI()">
                    <span class="radio-label">Disabled</span>
                    <span class="radio-desc">No automatic cleanup</span>
                </label>
                <label class="radio-option <?= $ptc_cfg['CLEANUP_MODE'] == 'smart' ? 'selected' : '' ?>">
                    <input type="radio" name="CLEANUP_MODE" value="smart" <?= $ptc_cfg['CLEANUP_MODE'] == 'smart' ? 'checked' : '' ?> onchange="updateCleanupUI()">
                    <span class="radio-label">Smart Cleanup</span>
                    <span class="radio-desc">Remove watched media automatically</span>
                </label>
                <label class="radio-option <?= $ptc_cfg['CLEANUP_MODE'] == 'days' ? 'selected' : '' ?>">
                    <input type="radio" name="CLEANUP_MODE" value="days" <?= $ptc_cfg['CLEANUP_MODE'] == 'days' ? 'checked' : '' ?> onchange="updateCleanupUI()">
                    <span class="radio-label">Days-based</span>
                    <span class="radio-desc">Move files after X days</span>
                </label>
            </div>

            <div id="smart-cleanup-options" class="cleanup-options" style="display: <?= $ptc_cfg['CLEANUP_MODE'] == 'smart' ? 'block' : 'none' ?>;">
                <div class="form-pair"><label data-tooltip="Delay in seconds before deleting watched movies.">Delete Delay:</label><div class="form-input-wrapper"><input type="number" name="MOVIE_DELETE_DELAY" value="<?= htmlspecialchars($ptc_cfg['MOVIE_DELETE_DELAY']) ?>" class="ptc-input input-small"><span class="unit-label">sec</span></div></div>
                <div class="form-pair"><label data-tooltip="Number of previous episodes to keep in cache.">Keep Episodes:</label><div class="form-input-wrapper"><input type="number" name="EPISODE_KEEP_PREVIOUS" value="<?= htmlspecialchars($ptc_cfg['EPISODE_KEEP_PREVIOUS']) ?>" class="ptc-input input-small"><span class="unit-label">ep</span></div></div>
            </div>

            <div id="days-cleanup-options" class="cleanup-options" style="display: <?= $ptc_cfg['CLEANUP_MODE'] == 'days' ? 'block' : 'none' ?>;">
                <div class="form-pair"><label data-tooltip="Move cached files back to array after this many days.">Max Days:</label><div class="form-input-wrapper"><input type="number" name="CACHE_MAX_DAYS" value="<?= htmlspecialchars($ptc_cfg['CACHE_MAX_DAYS']) ?>" class="ptc-input input-small"><span class="unit-label">days</span></div></div>
            </div>

            <div class="cache-info">
                <strong>Tracked Media Files:</strong> <?= $tracked_count ?> files cached by this plugin
            </div>

            <button type="button" class="btn-action warning" onclick="moveOther()"><i class="fa fa-arrow-right"></i> Move Other Files to Array</button>
            <button type="button" class="btn-action warning" onclick="clearCache()"><i class="fa fa-arrow-right"></i> Move Cached Media to Array</button>
            <button type="button" class="btn-action danger" onclick="moveAll()"><i class="fa fa-arrow-right"></i> Move ALL to Array</button>
        </div>

        <div class="ptc-col" id="ptc-col-log">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h3 style="margin:0; color:var(--primary-blue); font-size: 18px;"><i class="fa fa-terminal"></i> Live Log Output</h3>
                <div style="display:flex; align-items:center; gap:8px;">
                    <label style="color:#888; font-size:12px; cursor:pointer; display:flex; align-items:center; gap:4px;">
                        <input type="checkbox" id="auto_refresh" checked style="width:12px;height:12px;"> Auto Refresh
                    </label>
                    <button type="button" onclick="refreshLog();" style="padding: 4px 10px; font-size: 12px; cursor: pointer;">Refresh</button>
                </div>
            </div>
            <div id="ptc-log">Loading Logs...</div>
        </div>
    </div>
</form>

<script>
function refreshLog() {
    $.get('/plugins/plex_to_cache/plex_to_cache.php?action=log', function(data) {
        var logDiv = $('#ptc-log');
        logDiv.text(data);
        logDiv.scrollTop(logDiv[0].scrollHeight);
    });
}

function addMappingRow(dockerVal = '', hostVal = '') {
    var table = document.getElementById('mapping_table').getElementsByTagName('tbody')[0];
    var row = table.insertRow(-1);
    var cell1 = row.insertCell(0); var cell2 = row.insertCell(1); var cell3 = row.insertCell(2);
    cell1.innerHTML = '<input type="text" name="mapping_host[]" value="' + hostVal + '" class="ptc-input" style="padding:4px !important; height:26px !important;">';
    cell2.innerHTML = '<input type="text" name="mapping_docker[]" value="' + dockerVal + '" class="ptc-input" style="padding:4px !important; height:26px !important;">';
    cell3.innerHTML = '<a href="#" onclick="deleteRow(this); return false;" style="color:#ff4444; font-size:16px; margin-left:5px;"><i class="fa fa-minus-circle"></i></a>';
}

function deleteRow(btn) {
    var row = btn.parentNode.parentNode;
    row.parentNode.removeChild(row);
}

function testConnection(service, btn) {
    btn.textContent = '...';
    btn.className = 'btn-test';
    $.getJSON('/plugins/plex_to_cache/plex_to_cache.php?action=test&service=' + service, function(data) {
        if (data.success) {
            btn.textContent = 'OK';
            btn.className = 'btn-test success';
        } else {
            btn.textContent = 'Fail';
            btn.className = 'btn-test error';
        }
        btn.title = data.message;
        setTimeout(function() {
            btn.textContent = 'Test';
            btn.className = 'btn-test';
        }, 3000);
    }).fail(function() {
        btn.textContent = 'Fail';
        btn.className = 'btn-test error';
        setTimeout(function() {
            btn.textContent = 'Test';
            btn.className = 'btn-test';
        }, 3000);
    });
}

function clearCache() {
    if (!confirm('This will move all media files cached by this plugin back to the array. Continue?')) return;
    alert('Moving cached media files... This may take a while.');
    $.getJSON('/plugins/plex_to_cache/plex_to_cache.php?action=clearcache', function(data) {
        alert(data.message);
        location.reload();
    }).fail(function() {
        alert('Failed to move cached media');
    });
}

function moveOther() {
    if (!confirm('This will move ALL files from cache to array EXCEPT the media files cached by this plugin. Continue?')) return;
    alert('Moving files... This may take a while. Check the log for progress.');
    $.getJSON('/plugins/plex_to_cache/plex_to_cache.php?action=moveother', function(data) {
        alert(data.message);
        refreshLog();
    }).fail(function() {
        alert('Failed to move files');
    });
}

function moveAll() {
    if (!confirm('This will move ALL files from cache to array, including media files cached by this plugin. Continue?')) return;
    alert('Moving all files... This may take a while. Check the log for progress.');
    $.getJSON('/plugins/plex_to_cache/plex_to_cache.php?action=moveall', function(data) {
        alert(data.message);
        location.reload();
    }).fail(function() {
        alert('Failed to move files');
    });
}

function serviceControl(cmd) {
    $.getJSON('/plugins/plex_to_cache/plex_to_cache.php?action=service&cmd=' + cmd, function(data) {
        var dot = document.getElementById('status-dot');
        var text = document.getElementById('status-text');
        if (data.running) {
            dot.className = 'status-dot running';
            text.textContent = 'Running';
        } else {
            dot.className = 'status-dot stopped';
            text.textContent = 'Stopped';
        }
    });
}

function updateCleanupUI() {
    var mode = document.querySelector('input[name="CLEANUP_MODE"]:checked').value;
    document.getElementById('smart-cleanup-options').style.display = mode === 'smart' ? 'block' : 'none';
    document.getElementById('days-cleanup-options').style.display = mode === 'days' ? 'block' : 'none';
    document.querySelectorAll('.radio-option').forEach(function(el) {
        el.classList.remove('selected');
    });
    document.querySelector('input[name="CLEANUP_MODE"]:checked').closest('.radio-option').classList.add('selected');
}

$(function() {
    <?php foreach ($mappings_pairs as $pair): ?>
    addMappingRow('<?= addslashes($pair[0]) ?>', '<?= addslashes($pair[1]) ?>');
    <?php endforeach; ?>
    if (document.getElementById('mapping_table').rows.length <= 1) { addMappingRow(); }
    refreshLog();
    setInterval(function() { if ($('#auto_refresh').is(':checked')) refreshLog(); }, 3000);
});
</script>
]]>
</INLINE>
</FILE>

<FILE Name="/usr/local/emhttp/plugins/plex_to_cache/scripts/plex_to_cache.py" Mode="0755">
<INLINE>
<![CDATA[
#!/usr/bin/python3
import requests
import os
import shutil
import subprocess
import time
import sys
import re
import fcntl
import signal
import urllib3
from pathlib import Path

# Disable SSL warnings for self-signed certificates
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# ==========================================
# --- CONFIGURATION DEFAULTS ---
# ==========================================

CONFIG_FILE = "/boot/config/plugins/plex_to_cache/settings.cfg"
TRACKED_FILES = "/boot/config/plugins/plex_to_cache/cached_files.list"
LOCK_FILE_PATH = "/tmp/media_cache_cleaner.lock"

# Hardcoded Perms Root (Physical Disks ONLY - No Cache)
# We use /mnt/user0 to verify if a file is really on the array.
PERMS_ROOT = "/mnt/user0"

CONFIG = {
    "ENABLE_PLEX": "False",
    "PLEX_URL": "http://localhost:32400",
    "PLEX_TOKEN": "",

    "ENABLE_EMBY": "False",
    "EMBY_URL": "http://localhost:8096",
    "EMBY_API_KEY": "",

    "ENABLE_JELLYFIN": "False",
    "JELLYFIN_URL": "http://localhost:8096",
    "JELLYFIN_API_KEY": "",

    "CHECK_INTERVAL": "10",
    "CACHE_MAX_USAGE": "80",
    "COPY_DELAY": "30",
    "CLEANUP_MODE": "none",  # "none", "smart", or "days"
    "MOVIE_DELETE_DELAY": "1800",
    "EPISODE_KEEP_PREVIOUS": "2",
    "CACHE_MAX_DAYS": "7",  # Days before files are moved back to array
    "EXCLUDE_DIRS": "",
    "MEDIA_FILETYPES": ".mkv .mp4 .avi",
    "ARRAY_ROOT": "/mnt/user",
    "CACHE_ROOT": "/mnt/cache",
    "DOCKER_MAPPINGS": ""
}

# --- INTERNAL VARIABLES ---
movie_deletion_queue = {}
stream_start_times = {}
metadata_path_cache = {}
parsed_docker_mappings = {}

# ---------------------

def log_info(msg):
    print(msg, flush=True)

def log_error(msg):
    print(f"[Error] {msg}", flush=True)

# --- TRACKING FUNCTIONS ---

def load_tracked_files():
    """Load tracked files with timestamps. Format: path|timestamp"""
    tracked = {}
    if os.path.exists(TRACKED_FILES):
        try:
            with open(TRACKED_FILES, 'r') as f:
                for line in f:
                    line = line.strip()
                    if not line:
                        continue
                    if '|' in line:
                        path, ts = line.rsplit('|', 1)
                        tracked[path] = float(ts)
                    else:
                        # Legacy format without timestamp
                        tracked[line] = time.time()
        except Exception as e:
            log_error(f"Failed to load tracked files: {e}")
    return tracked

def save_tracked_files(tracked):
    """Save tracked files with timestamps."""
    try:
        with open(TRACKED_FILES, 'w') as f:
            for path, ts in sorted(tracked.items()):
                f.write(f"{path}|{ts}\n")
    except Exception as e:
        log_error(f"Failed to save tracked files: {e}")

def track_cached_file(cache_path):
    """Add a file to the tracking list with current timestamp."""
    tracked = load_tracked_files()
    if cache_path not in tracked:
        tracked[cache_path] = time.time()
        save_tracked_files(tracked)

def untrack_cached_file(cache_path):
    """Remove a file from the tracking list."""
    tracked = load_tracked_files()
    if cache_path in tracked:
        del tracked[cache_path]
        save_tracked_files(tracked)

def get_tracked_files_set():
    """Get just the file paths as a set (for compatibility)."""
    return set(load_tracked_files().keys())

def parse_docker_mappings(mapping_str):
    mappings = {}
    if not mapping_str:
        return mappings
    pairs = mapping_str.split(';')
    for pair in pairs:
        if ':' in pair:
            k, v = pair.split(':', 1)
            mappings[k.strip()] = v.strip()
    return mappings

def load_config():
    global CONFIG, parsed_docker_mappings
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r') as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith("#"): continue
                    if "=" in line:
                        key, value = line.split("=", 1)
                        key = key.strip()
                        value = value.strip().strip('"').strip("'")
                        CONFIG[key] = value
        except Exception as e:
            log_error(f"Failed to load config: {e}")

    parsed_docker_mappings = parse_docker_mappings(CONFIG.get("DOCKER_MAPPINGS", ""))

def get_config_bool(key):
    val = CONFIG.get(key, "False")
    return val.lower() == "true" or val == "1"

def get_config_int(key):
    try: return int(CONFIG.get(key, 0))
    except: return 0

def acquire_lock():
    global lock_file
    lock_file = open(LOCK_FILE_PATH, 'w')
    try:
        fcntl.lockf(lock_file, fcntl.LOCK_EX | fcntl.LOCK_NB)
    except IOError:
        log_error("Another instance is already running")
        sys.exit(1)

# --- PERMISSIONS LOGIC ---

def get_perms_reference_path(cache_path):
    CACHE_ROOT = CONFIG["CACHE_ROOT"]
    if cache_path.startswith(CACHE_ROOT):
        return cache_path.replace(CACHE_ROOT, PERMS_ROOT, 1)
    return None

def clone_rights_from_disk(dst_path):
    src_path = get_perms_reference_path(dst_path)
    if not src_path or not os.path.exists(src_path):
        return
    try:
        st = os.stat(src_path)
        os.chown(dst_path, st.st_uid, st.st_gid)
        os.chmod(dst_path, st.st_mode)
    except Exception as e:
        log_error(f"Failed to clone permissions: {e}")

# --- HELPERS ---

def is_excluded(path):
    EXCLUDE_DIRS = CONFIG["EXCLUDE_DIRS"]
    if not EXCLUDE_DIRS: return False
    path_parts = path.split(os.sep)
    excludes = [x.strip() for x in EXCLUDE_DIRS.split(',')]
    for exc in excludes:
        if exc and exc in path_parts: return True
    return False

def is_trigger_filetype(filename):
    MEDIA_FILETYPES = CONFIG["MEDIA_FILETYPES"]
    if not MEDIA_FILETYPES: return True
    valid_exts = [x.strip().lower() for x in MEDIA_FILETYPES.split()]
    lower_name = filename.lower()
    for ext in valid_exts:
        if lower_name.endswith(ext): return True
    return False

# --- API CLIENTS ---

def plex_api_get(endpoint):
    headers = {'X-Plex-Token': CONFIG["PLEX_TOKEN"], 'Accept': 'application/json'}
    try:
        r = requests.get(f"{CONFIG['PLEX_URL']}{endpoint}", headers=headers, timeout=5, verify=False)
        return r.json()
    except Exception as e:
        log_error(f"Plex API request failed: {e}")
        return None

def emby_api_get(endpoint, key, url):
    headers = {'X-Emby-Token': key, 'Accept': 'application/json'}
    try:
        r = requests.get(f"{url}{endpoint}", headers=headers, timeout=5, verify=False)
        return r.json()
    except Exception as e:
        log_error(f"Emby/Jellyfin API request failed: {e}")
        return None

def get_active_sessions():
    active_items = {}
    if get_config_bool("ENABLE_PLEX"):
        data = plex_api_get("/status/sessions")
        if data and 'MediaContainer' in data and 'Metadata' in data['MediaContainer']:
            for item in data['MediaContainer']['Metadata']:
                rk = item.get('ratingKey')
                found = metadata_path_cache.get(rk)
                if not found and 'Media' in item:
                    for media in item['Media']:
                        for part in media.get('Part', []):
                            if part.get('file'): found = part['file']; break
                if not found and rk:
                    meta = plex_api_get(f"/library/metadata/{rk}")
                    if meta and 'MediaContainer' in meta and 'Metadata' in meta['MediaContainer']:
                        for m in meta['MediaContainer']['Metadata']:
                            for med in m.get('Media', []):
                                for p in med.get('Part', []):
                                    if p.get('file'): found = p['file']; break
                if found:
                    metadata_path_cache[rk] = found
                    active_items[found] = {'service': 'plex', 'id': rk}

    for svc in [("ENABLE_EMBY", "EMBY_API_KEY", "EMBY_URL", "emby"), ("ENABLE_JELLYFIN", "JELLYFIN_API_KEY", "JELLYFIN_URL", "jellyfin")]:
        if get_config_bool(svc[0]):
            data = emby_api_get("/Sessions", CONFIG[svc[1]], CONFIG[svc[2]])
            if data:
                for s in data:
                    p = s.get('NowPlayingItem', {}).get('Path')
                    if p: active_items[p] = {'service': svc[3], 'id': s['NowPlayingItem'].get('Id'), 'user': s.get('UserId')}
    return active_items

def check_is_watched(session_data):
    if not session_data: return False
    service = session_data.get('service')
    if service == 'plex':
        rk = session_data.get('id')
        data = plex_api_get(f"/library/metadata/{rk}")
        if data and 'MediaContainer' in data and 'Metadata' in data['MediaContainer']:
            meta = data['MediaContainer']['Metadata'][0]
            if 'viewCount' in meta and meta['viewCount'] > 0: return True
    elif service in ['emby', 'jellyfin']:
        u = CONFIG["EMBY_URL"] if service == 'emby' else CONFIG["JELLYFIN_URL"]
        k = CONFIG["EMBY_API_KEY"] if service == 'emby' else CONFIG["JELLYFIN_API_KEY"]
        d = emby_api_get(f"/Users/{session_data.get('user')}/Items/{session_data.get('id')}", k, u)
        if d and 'UserData' in d: return d['UserData'].get('Played', False)
    return False

# --- PATH TOOLS ---

def translate_path(docker_path):
    clean_path = docker_path.replace('\\', '/')
    ARRAY_ROOT = CONFIG["ARRAY_ROOT"]
    for d_prefix, real_prefix in parsed_docker_mappings.items():
        if clean_path.startswith(d_prefix):
            rel_path = clean_path[len(d_prefix):].lstrip('/')
            return os.path.join(real_prefix if real_prefix.startswith(ARRAY_ROOT) else os.path.join(ARRAY_ROOT, real_prefix.lstrip('/')), rel_path).replace('//', '/')
    return clean_path

def get_cache_path(array_path):
    ARRAY_ROOT = CONFIG["ARRAY_ROOT"]
    CACHE_ROOT = CONFIG["CACHE_ROOT"]
    if array_path.startswith(ARRAY_ROOT): return array_path.replace(ARRAY_ROOT, CACHE_ROOT, 1)
    return None

def parse_episode_number(filename):
    match = re.search(r"[sS]\d+[eE](\d+)", filename)
    return int(match.group(1)) if match else None

def is_last_episode_on_array(file_path):
    try:
        ep_num = parse_episode_number(os.path.basename(file_path))
        if ep_num is None: return False
        folder = os.path.dirname(file_path)
        max_ep = 0
        if os.path.exists(folder):
            for f in os.listdir(folder):
                e = parse_episode_number(f)
                if e and e > max_ep: max_ep = e
        return ep_num >= max_ep
    except Exception as e:
        log_error(f"Failed to check last episode: {e}")
        return False

# --- MOVER / DELETE LOGIC ---

def cleanup_empty_parent_dirs(path):
    parent_dir = os.path.dirname(path)
    CACHE_ROOT = CONFIG["CACHE_ROOT"]
    protected = [os.path.join(CACHE_ROOT, m.strip("/")) for m in parsed_docker_mappings.values()]
    while parent_dir.startswith(CACHE_ROOT) and len(parent_dir) > len(CACHE_ROOT):
        if parent_dir in protected: break
        try:
            os.rmdir(parent_dir)
            parent_dir = os.path.dirname(parent_dir)
        except OSError: break

def move_to_array(cache_path):
    CACHE_ROOT = CONFIG["CACHE_ROOT"]
    rel_path = cache_path.replace(CACHE_ROOT, "").lstrip("/")
    dest_path = os.path.join(PERMS_ROOT, rel_path)

    log_info(f"[Mover] -> Array: {os.path.basename(cache_path)}")
    try:
        os.makedirs(os.path.dirname(dest_path), exist_ok=True)
        subprocess.run(["rsync", "-a", "--remove-source-files", cache_path, dest_path], check=True, stdout=subprocess.DEVNULL)
        clone_rights_from_disk(dest_path)
        cleanup_empty_parent_dirs(cache_path)
        untrack_cached_file(cache_path)
    except Exception as e:
        log_error(f"Move to array failed: {e}")

def smart_manage_cache_file(cache_path, reason="Cleanup"):
    if not os.path.exists(cache_path): return
    rel_path = cache_path.replace(CONFIG["CACHE_ROOT"], "").lstrip("/")
    array_path = os.path.join(PERMS_ROOT, rel_path)

    # We check against PERMS_ROOT (/mnt/user0) to be absolutely sure the file is on the array
    if os.path.exists(array_path):
        if os.path.getsize(cache_path) == os.path.getsize(array_path):
            os.remove(cache_path)
            log_info(f"[{reason}] Deleted: {os.path.basename(cache_path)}")
            cleanup_empty_parent_dirs(cache_path)
            untrack_cached_file(cache_path)
    else:
        # Not on array yet, so move it instead of just deleting
        move_to_array(cache_path)

def ensure_structure(full_cache_file_path):
    CACHE_ROOT = CONFIG["CACHE_ROOT"]
    try: rel_path = os.path.relpath(os.path.dirname(full_cache_file_path), CACHE_ROOT)
    except: return
    curr = CACHE_ROOT
    for part in rel_path.split(os.sep):
        if not part or part == ".": continue
        curr = os.path.join(curr, part)
        if not os.path.exists(curr):
            try:
                os.mkdir(curr)
                clone_rights_from_disk(curr)
            except Exception as e:
                log_error(f"Failed to create directory {curr}: {e}")

def cache_file_if_needed(source_path):
    rel_path = source_path.replace(CONFIG["ARRAY_ROOT"], "").lstrip("/")
    if not rel_path or is_excluded(rel_path): return
    dest_path = os.path.join(CONFIG["CACHE_ROOT"], rel_path)

    if os.path.exists(dest_path) and os.path.getsize(source_path) == os.path.getsize(dest_path):
        if dest_path in movie_deletion_queue: del movie_deletion_queue[dest_path]
        # Make sure it's tracked even if already exists
        track_cached_file(dest_path)
        return

    try:
        usage = shutil.disk_usage(CONFIG["CACHE_ROOT"])
        if (usage.used / usage.total) * 100 >= get_config_int("CACHE_MAX_USAGE"): return
    except Exception as e:
        log_error(f"Failed to check disk usage: {e}")
        return

    log_info(f"[Copy] -> {os.path.basename(source_path)}")
    try:
        ensure_structure(dest_path)
        subprocess.run(["rsync", "-a", source_path, dest_path], check=True, stdout=subprocess.DEVNULL)
        clone_rights_from_disk(dest_path)
        track_cached_file(dest_path)
    except Exception as e:
        log_error(f"Copy failed: {e}")

# --- HANDLER ---

def handle_series_smart(rp):
    curr_ep = parse_episode_number(os.path.basename(rp))
    if curr_ep is None: return handle_movie_logic(rp)
    sd_array = os.path.dirname(rp)
    sd_cache = get_cache_path(sd_array)
    cleanup_mode = CONFIG.get("CLEANUP_MODE", "none").lower()
    if cleanup_mode == "smart" and sd_cache and os.path.exists(sd_cache):
        th = curr_ep - get_config_int("EPISODE_KEEP_PREVIOUS")
        for f in os.listdir(sd_cache):
            num = parse_episode_number(f)
            if num is not None and num < th:
                smart_manage_cache_file(os.path.join(sd_cache, f), "Smart Cleanup")
    try:
        if os.path.exists(sd_array):
            for f in sorted(os.listdir(sd_array)):
                num = parse_episode_number(f)
                if num is not None and num >= curr_ep: cache_file_if_needed(os.path.join(sd_array, f))
    except Exception as e:
        log_error(f"Series handling failed: {e}")

def handle_movie_logic(rp):
    cache_file_if_needed(rp)
    try:
        folder, stem = os.path.dirname(rp), os.path.splitext(os.path.basename(rp))[0]
        if os.path.exists(folder):
            for f in os.listdir(folder):
                if f.startswith(stem): cache_file_if_needed(os.path.join(folder, f))
    except Exception as e:
        log_error(f"Movie handling failed: {e}")

def cleanup_by_days():
    """Move files back to array if they've been cached longer than CACHE_MAX_DAYS."""
    max_days = get_config_int("CACHE_MAX_DAYS")
    if max_days <= 0:
        return

    max_age_seconds = max_days * 24 * 60 * 60
    tracked = load_tracked_files()
    now = time.time()

    for cache_path, cached_time in list(tracked.items()):
        age = now - cached_time
        if age > max_age_seconds:
            if os.path.exists(cache_path):
                log_info(f"[Days Cleanup] {os.path.basename(cache_path)} cached for {int(age/86400)} days")
                smart_manage_cache_file(cache_path, "Days Cleanup")

if __name__ == "__main__":
    load_config(); acquire_lock()
    signal.signal(signal.SIGHUP, lambda s, f: load_config())
    log_info("Service started. Waiting for streams...")
    last_loop_sessions = {}
    last_days_check = 0
    while True:
        try:
            curr_sessions = get_active_sessions()
            active_paths = []
            for dp, s_data in curr_sessions.items():
                rp = translate_path(dp)
                if not rp.startswith(CONFIG["ARRAY_ROOT"]) or is_excluded(rp) or not is_trigger_filetype(os.path.basename(rp)): continue
                active_paths.append(rp)
                if rp not in stream_start_times:
                    log_info(f"[Stream] Active: {os.path.basename(rp)}")
                    stream_start_times[rp] = time.time(); continue
                if time.time() - stream_start_times[rp] >= get_config_int("COPY_DELAY"):
                    if parse_episode_number(os.path.basename(rp)) is not None: handle_series_smart(rp)
                    else: handle_movie_logic(rp)
            for p in list(stream_start_times.keys()):
                if p not in set(active_paths): del stream_start_times[p]

            cleanup_mode = CONFIG.get("CLEANUP_MODE", "none").lower()

            # Smart cleanup: triggered by watching behavior
            if cleanup_mode == "smart":
                stopped = set(last_loop_sessions.keys()) - set(curr_sessions.keys())
                for d_p in stopped:
                    s_d, r_p = last_loop_sessions[d_p], translate_path(d_p)
                    if check_is_watched(s_d):
                        cp = get_cache_path(r_p)
                        if cp and os.path.exists(cp):
                            if parse_episode_number(os.path.basename(r_p)) is None: movie_deletion_queue[cp] = time.time()
                            elif is_last_episode_on_array(r_p):
                                for f in os.listdir(os.path.dirname(cp)):
                                    movie_deletion_queue[os.path.join(os.path.dirname(cp), f)] = time.time()
                for cp, ts in list(movie_deletion_queue.items()):
                    if time.time() - ts > get_config_int("MOVIE_DELETE_DELAY"):
                        smart_manage_cache_file(cp, "Deletion Timer"); del movie_deletion_queue[cp]

            # Days-based cleanup: check once per hour
            elif cleanup_mode == "days":
                if time.time() - last_days_check > 3600:
                    cleanup_by_days()
                    last_days_check = time.time()

            last_loop_sessions = curr_sessions
        except Exception as e:
            log_error(f"Main loop error: {e}")
        time.sleep(get_config_int("CHECK_INTERVAL"))
]]>
</INLINE>
</FILE>

<FILE Name="/usr/local/emhttp/plugins/plex_to_cache/scripts/rc.plex_to_cache" Mode="0755">
<INLINE>
<![CDATA[
#!/bin/bash
PYTHON_SCRIPT="/usr/local/emhttp/plugins/plex_to_cache/scripts/plex_to_cache.py"
PID_FILE="/var/run/plex_to_cache.pid"
LOG_FILE="/var/log/plex_to_cache.log"
start() {
    if [ -f "$PID_FILE" ] && ps -p $(cat "$PID_FILE") > /dev/null; then return;
    fi
    echo "Starting Plex to Cache Service..."
    nohup python3 "$PYTHON_SCRIPT" > "$LOG_FILE" 2>&1 &
    echo $! > "$PID_FILE"
}
stop() {
    if [ -f "$PID_FILE" ]; then kill $(cat "$PID_FILE") 2>/dev/null; rm "$PID_FILE"; fi
    pkill -f plex_to_cache.py 2>/dev/null
}
case "$1" in
    start) start ;;
    stop) stop ;;
    restart) stop; sleep 1; start ;;
esac
]]>
</INLINE>
</FILE>

<FILE Run="/bin/bash">
<INLINE>
<![CDATA[
chmod +x /usr/local/emhttp/plugins/plex_to_cache/scripts/rc.plex_to_cache
chmod +x /usr/local/emhttp/plugins/plex_to_cache/scripts/plex_to_cache.py
touch /var/log/plex_to_cache.log
chmod 666 /var/log/plex_to_cache.log
/usr/local/emhttp/plugins/plex_to_cache/scripts/rc.plex_to_cache restart
echo "Plex to Cache v&version; installed successfully."
]]>
</INLINE>
</FILE>

<FILE Run="/bin/bash" Method="remove">
<INLINE>
<![CDATA[
if [ -f /var/run/plex_to_cache.pid ]; then
    kill $(cat /var/run/plex_to_cache.pid) 2>/dev/null
    rm /var/run/plex_to_cache.pid
fi
pkill -f plex_to_cache.py 2>/dev/null
rm -rf /usr/local/emhttp/plugins/plex_to_cache
rm /var/log/plex_to_cache.log
echo "Plex to Cache uninstalled."
]]>
</INLINE>
</FILE>

</PLUGIN>
