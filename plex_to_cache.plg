<?xml version='1.0' standalone='yes'?>
<!DOCTYPE PLUGIN [
<!ENTITY name      "plex_to_cache">
<!ENTITY author    "MajorPain007">
<!ENTITY version   "2025.12.30.04">
<!ENTITY launch    "Utilities/plex_to_cache">
<!ENTITY pluginURL "https://raw.githubusercontent.com/MajorPain007/unraid-move-to-cache/main/plex_to_cache.plg">
]>
<PLUGIN name="&name;" author="&author;" version="&version;" launch="&launch;" pluginURL="&pluginURL;" icon="server">

<DESCRIPTION>
Automatically moves media from Unraid array to cache when a stream starts in Plex, Emby or Jellyfin. Includes smart cleanup, permission mirroring and season-ahead caching.
</DESCRIPTION>

<!-- 
    INSTALLATION STRATEGY: 
    1. Download files to /tmp/plex_to_cache_install/ first.
    2. The install script (Run="/bin/bash") will handle the stop, wipe, move, and restart logic.
    This prevents the "delete itself" bug where rm -rf deletes files just unpacked by Unraid.
-->

<FILE Name="/tmp/plex_to_cache_install/plex_to_cache.page">
<INLINE>
<![CDATA[
Menu="Utilities"
Icon="server"
Title="Plex to Cache"
---
<?php include '/usr/local/emhttp/plugins/plex_to_cache/plex_to_cache.php'; ?>
]]>
</INLINE>
</FILE>

<FILE Name="/tmp/plex_to_cache_install/plex_to_cache.php">
<INLINE>
<![CDATA[
<?php
$ptc_plugin = "plex_to_cache";
$ptc_cfg_file = "/boot/config/plugins/$ptc_plugin/settings.cfg";
$ptc_log_file = "/var/log/plex_to_cache.log";

// Defaults
$ptc_cfg = [
    "LANGUAGE" => "EN",
    "ENABLE_PLEX" => "False", "PLEX_URL" => "http://localhost:32400", "PLEX_TOKEN" => "",
    "ENABLE_EMBY" => "False", "EMBY_URL" => "http://localhost:8096", "EMBY_API_KEY" => "",
    "ENABLE_JELLYFIN" => "False", "JELLYFIN_URL" => "http://localhost:8096", "JELLYFIN_API_KEY" => "",
    "CHECK_INTERVAL" => "10", "CACHE_MAX_USAGE" => "80", "COPY_DELAY" => "30",
    "ENABLE_SMART_CLEANUP" => "False", "MOVIE_DELETE_DELAY" => "1800", "EPISODE_KEEP_PREVIOUS" => "2",
    "EXCLUDE_DIRS" => "", "MEDIA_FILETYPES" => ".mkv .mp4 .avi", "ARRAY_ROOT" => "/mnt/user",
    "CACHE_ROOT" => "/mnt/cache", "DOCKER_MAPPINGS" => "/media:/Media;/movies:/Media/Movies;/tv:/Media/TV"
];

// Load Config
if (file_exists($ptc_cfg_file)) {
    $ptc_loaded = parse_ini_file($ptc_cfg_file);
    if ($ptc_loaded) {
        $ptc_cfg = array_merge($ptc_cfg, $ptc_loaded);
    }
}

// Translations
$lang = isset($ptc_cfg['LANGUAGE']) && $ptc_cfg['LANGUAGE'] == 'DE' ? 'DE' : 'EN';
$txt = [
    'DE' => [
        'settings' => 'Einstellungen', 'save' => 'Speichern & Übernehmen', 'plex' => 'Plex Media Server',
        'emby' => 'Emby Server', 'jelly' => 'Jellyfin Server', 'enable' => 'Aktivieren:',
        'paths' => 'Pfad Konfiguration', 'mappings' => 'Docker Pfad Mappings', 'tuning' => 'Tuning & Cleanup',
        'interval' => 'Check Intervall:', 'delay' => 'Kopier Verzögerung:', 'max_cache' => 'Max Cache:',
        'smart' => 'Smart Cleanup:', 'del_delay' => 'Lösch Verzögerung:', 'keep' => 'Episoden behalten:',
        'host' => 'Host Pfad (Unraid)', 'docker' => 'Docker Pfad (Container)', 'log' => 'Log Auswertung',
        'lang' => 'Sprache / Language', 'exclude' => 'Ordner ausschließen:', 'filetypes' => 'Dateitypen:',
        'status_saved' => 'Einstellungen gespeichert & Dienst neugestartet',
        'unit_sec' => 'sek', 'unit_percent' => '%', 'unit_count' => 'Anzahl'
    ],
    'EN' => [
        'settings' => 'Settings', 'save' => 'Save & Apply', 'plex' => 'Plex Media Server',
        'emby' => 'Emby Server', 'jelly' => 'Jellyfin Server', 'enable' => 'Enable:',
        'paths' => 'Storage Paths', 'mappings' => 'Docker Path Mappings', 'tuning' => 'Tuning & Cleanup',
        'interval' => 'Check Interval:', 'delay' => 'Copy Delay:', 'max_cache' => 'Max Cache:',
        'smart' => 'Smart Cleanup:', 'del_delay' => 'Delete Delay:', 'keep' => 'Keep Episodes:',
        'host' => 'Host Path (Unraid)', 'docker' => 'Docker Path (Container)', 'log' => 'Log Output',
        'lang' => 'Language', 'exclude' => 'Exclude Dirs:', 'filetypes' => 'File Types:',
        'status_saved' => 'Settings Saved & Service Restarted',
        'unit_sec' => 'sec', 'unit_percent' => '%', 'unit_count' => 'count'
    ]
];

// Handle Submit
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    foreach ($ptc_cfg as $key => $val) {
        if (isset($_POST[$key])) {
            $ptc_cfg[$key] = $_POST[$key];
        } else {
            if (strpos($key, "ENABLE_") === 0 || $key === "ENABLE_SMART_CLEANUP") {
                 $ptc_cfg[$key] = "False";
            }
        }
    }
    
    // Process Docker Mappings
    $mappings_str = "";
    if (isset($_POST['mapping_docker']) && isset($_POST['mapping_host'])) {
        $dockers = $_POST['mapping_docker'];
        $hosts = $_POST['mapping_host'];
        $pairs = [];
        for ($i = 0; $i < count($dockers); $i++) {
            $d = trim($dockers[$i]);
            $h = trim($hosts[$i]);
            if (!empty($d) && !empty($h)) {
                $pairs[] = "$d:$h";
            }
        }
        $mappings_str = implode(";", $pairs);
    }
    $ptc_cfg['DOCKER_MAPPINGS'] = $mappings_str;

    // Write Config
    $content = "";
    foreach ($ptc_cfg as $key => $val) {
        $content .= "$key=\"$val\"\n";
    }
    
    if (!is_dir(dirname($ptc_cfg_file))) mkdir(dirname($ptc_cfg_file), 0777, true);
    file_put_contents($ptc_cfg_file, $content);
    
    shell_exec("/usr/local/emhttp/plugins/plex_to_cache/scripts/rc.plex_to_cache restart");
    $save_msg = $txt[$lang]['status_saved'];
    
    // Refresh to apply language change immediately if changed
    echo "<script>window.location.reload();</script>";
}

// Prepare Mappings for JS
$mappings_pairs = [];
if (!empty($ptc_cfg['DOCKER_MAPPINGS'])) {
    $pairs = explode(";", $ptc_cfg['DOCKER_MAPPINGS']);
    foreach ($pairs as $pair) {
        if (strpos($pair, ":") !== false) {
            $mappings_pairs[] = explode(":", $pair, 2);
        }
    }
}
?>

<style>
:root { --primary-blue: #00aaff; --bg-dark: #111; }
#ptc-wrapper { display: flex; flex-wrap: nowrap; align-items: flex-start; justify-content: space-between; gap: 20px; width: 100%; box-sizing: border-box; padding: 10px 0; }
#ptc-settings, #ptc-log-container { background: var(--bg-dark); border-radius: 12px; box-shadow: 0 0 12px rgba(0, 170, 255, 0.2); color: #f0f8ff; padding: 20px; box-sizing: border-box; }
#ptc-settings { flex: 0 0 48%; }
#ptc-log-container { flex: 0 0 50%; display: flex; flex-direction: column; min-height: 850px; }
.section-header { color: var(--primary-blue); font-size: 18px; font-weight: bold; margin-bottom: 15px; margin-top: 25px; border-bottom: 1px solid #333; padding-bottom: 5px; }
.section-header:first-of-type { margin-top: 0; }
.form-pair { display: flex; align-items: center; margin-bottom: 15px; gap: 10px; }
.form-pair label { flex: 0 0 140px; color: var(--primary-blue); font-weight: bold; font-size: 14px; }
.form-input-wrapper { flex: 1; display: flex; align-items: center; }
.form-input-wrapper input[type="text"], .form-input-wrapper input[type="password"], .form-input-wrapper input[type="number"], .form-input-wrapper select { background: #111; border: 1px solid var(--primary-blue); border-radius: 5px; color: #fff; padding: 8px; width: 100%; box-sizing: border-box; }
.form-input-wrapper input[type="checkbox"] { accent-color: var(--primary-blue); width: 18px; height: 18px; cursor: pointer; }
.help-text { font-size: 12px; color: #888; margin-left: 8px; font-style: italic; }
#mapping_table { width: 100%; border-collapse: collapse; margin-top: 10px; }
#mapping_table th { text-align: left; color: var(--primary-blue); padding: 8px; border-bottom: 1px solid #333; font-size: 13px; }
#mapping_table td { padding: 5px; }
.btn-save { background: var(--primary-blue); color: #fff; border: none; border-radius: 4px; padding: 10px 20px; cursor: pointer; font-weight: bold; font-size: 14px; }
.btn-save:hover { filter: brightness(1.1); }
.btn-add { background: transparent; color: var(--primary-blue); border: 1px solid var(--primary-blue); padding: 5px 10px; border-radius: 4px; cursor: pointer; margin-top: 10px; }
.btn-add:hover { background: rgba(0, 170, 255, 0.1); }
#ptc-log { background: #000; border: 1px solid var(--primary-blue); border-radius: 8px; color: #00ffaa; font-family: monospace; font-size: 12px; padding: 15px; flex-grow: 1; overflow-y: auto; white-space: pre-wrap; word-break: break-all; }
.status-msg { background: rgba(46, 204, 64, 0.1); color: #2ECC40; padding: 10px; border-radius: 6px; margin-bottom: 20px; border: 1px solid #2ECC40; text-align: center; font-weight: bold; }
@media (max-width: 1100px) { #ptc-wrapper { flex-wrap: wrap; } #ptc-settings, #ptc-log-container { flex: 1 1 100%; } }
</style>

<div id="ptc-wrapper">

    <!-- LEFT COLUMN: SETTINGS -->
    <div id="ptc-settings">
        <form method="post" autocomplete="off">
            <?php if (isset($save_msg)) echo "<div class='status-msg'>$save_msg</div>"; ?>
            
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin:0; color:var(--primary-blue);"><?= $txt[$lang]['settings'] ?></h2>
                <input type="submit" value="<?= $txt[$lang]['save'] ?>" class="btn-save">
            </div>

            <div class="form-pair">
                <label><?= $txt[$lang]['lang'] ?>:</label>
                <div class="form-input-wrapper">
                    <select name="LANGUAGE" onchange="this.form.submit()">
                        <option value="EN" <?= $lang == 'EN' ? 'selected' : '' ?>>English</option>
                        <option value="DE" <?= $lang == 'DE' ? 'selected' : '' ?>>Deutsch</option>
                    </select>
                </div>
            </div>

            <!-- PLEX -->
            <div class="section-header"><i class="fa fa-play-circle"></i> <?= $txt[$lang]['plex'] ?></div>
            <div class="form-pair">
                <label><?= $txt[$lang]['enable'] ?></label>
                <div class="form-input-wrapper">
                    <input type="checkbox" name="ENABLE_PLEX" value="True" <?= $ptc_cfg['ENABLE_PLEX'] == 'True' ? 'checked' : '' ?> >
                </div>
            </div>
            <div class="form-pair">
                <label>Plex URL:</label>
                <div class="form-input-wrapper">
                    <input type="text" name="PLEX_URL" value="<?= $ptc_cfg['PLEX_URL'] ?>" placeholder="http://192.168.1.100:32400" autocomplete="off">
                </div>
            </div>
            <div class="form-pair">
                <label>Plex Token:</label>
                <div class="form-input-wrapper">
                    <input type="password" name="PLEX_TOKEN" value="<?= $ptc_cfg['PLEX_TOKEN'] ?>" onmouseover="this.type='text'" onmouseout="this.type='password'" autocomplete="new-password">
                </div>
            </div>

            <!-- EMBY -->
            <div class="section-header"><i class="fa fa-server"></i> <?= $txt[$lang]['emby'] ?></div>
            <div class="form-pair">
                <label><?= $txt[$lang]['enable'] ?></label>
                <div class="form-input-wrapper">
                    <input type="checkbox" name="ENABLE_EMBY" value="True" <?= $ptc_cfg['ENABLE_EMBY'] == 'True' ? 'checked' : '' ?> >
                </div>
            </div>
            <div class="form-pair">
                <label>Emby URL:</label>
                <div class="form-input-wrapper">
                    <input type="text" name="EMBY_URL" value="<?= $ptc_cfg['EMBY_URL'] ?>" placeholder="http://192.168.1.100:8096" autocomplete="off">
                </div>
            </div>
            <div class="form-pair">
                <label>API Key:</label>
                <div class="form-input-wrapper">
                    <input type="password" name="EMBY_API_KEY" value="<?= $ptc_cfg['EMBY_API_KEY'] ?>" onmouseover="this.type='text'" onmouseout="this.type='password'" autocomplete="new-password">
                </div>
            </div>

            <!-- JELLYFIN -->
            <div class="section-header"><i class="fa fa-film"></i> <?= $txt[$lang]['jelly'] ?></div>
            <div class="form-pair">
                <label><?= $txt[$lang]['enable'] ?></label>
                <div class="form-input-wrapper">
                    <input type="checkbox" name="ENABLE_JELLYFIN" value="True" <?= $ptc_cfg['ENABLE_JELLYFIN'] == 'True' ? 'checked' : '' ?> >
                </div>
            </div>
            <div class="form-pair">
                <label>Jellyfin URL:</label>
                <div class="form-input-wrapper">
                    <input type="text" name="JELLYFIN_URL" value="<?= $ptc_cfg['JELLYFIN_URL'] ?>" placeholder="http://192.168.1.100:8096" autocomplete="off">
                </div>
            </div>
            <div class="form-pair">
                <label>API Key:</label>
                <div class="form-input-wrapper">
                    <input type="password" name="JELLYFIN_API_KEY" value="<?= $ptc_cfg['JELLYFIN_API_KEY'] ?>" onmouseover="this.type='text'" onmouseout="this.type='password'" autocomplete="new-password">
                </div>
            </div>

            <!-- STORAGE -->
            <div class="section-header"><i class="fa fa-folder-open"></i> <?= $txt[$lang]['paths'] ?></div>
            <div class="form-pair">
                <label><?= $txt[$lang]['host'] ?>:</label>
                <div class="form-input-wrapper">
                    <input type="text" name="ARRAY_ROOT" value="<?= $ptc_cfg['ARRAY_ROOT'] ?>" autocomplete="off">
                </div>
            </div>
            <div class="form-pair">
                <label>Cache Root:</label>
                <div class="form-input-wrapper">
                    <input type="text" name="CACHE_ROOT" value="<?= $ptc_cfg['CACHE_ROOT'] ?>" autocomplete="off">
                </div>
            </div>
            <div class="form-pair">
                <label><?= $txt[$lang]['exclude'] ?></label>
                <div class="form-input-wrapper">
                    <input type="text" name="EXCLUDE_DIRS" value="<?= $ptc_cfg['EXCLUDE_DIRS'] ?>" placeholder="temp,downloads" autocomplete="off">
                </div>
            </div>

            <!-- MAPPINGS -->
            <div class="section-header"><i class="fa fa-exchange"></i> <?= $txt[$lang]['mappings'] ?></div>
            <table id="mapping_table">
                <thead>
                    <tr>
                        <th style="width: 45%;"><?= $txt[$lang]['docker'] ?></th>
                        <th style="width: 45%;"><?= $txt[$lang]['host'] ?></th>
                        <th style="width: 10%;"></th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
            <button type="button" class="btn-add" onclick="addMappingRow()">+ Mapping</button>

            <!-- TUNING -->
            <div class="section-header"><i class="fa fa-cogs"></i> <?= $txt[$lang]['tuning'] ?></div>
            <div class="form-pair">
                <label><?= $txt[$lang]['interval'] ?></label>
                <div class="form-input-wrapper">
                    <input type="number" name="CHECK_INTERVAL" value="<?= $ptc_cfg['CHECK_INTERVAL'] ?>" style="width: 100px;">
                    <span class="help-text"><?= $txt[$lang]['unit_sec'] ?></span>
                </div>
            </div>
            <div class="form-pair">
                <label><?= $txt[$lang]['delay'] ?></label>
                <div class="form-input-wrapper">
                    <input type="number" name="COPY_DELAY" value="<?= $ptc_cfg['COPY_DELAY'] ?>" style="width: 100px;">
                    <span class="help-text"><?= $txt[$lang]['unit_sec'] ?></span>
                </div>
            </div>
            <div class="form-pair">
                <label><?= $txt[$lang]['max_cache'] ?></label>
                <div class="form-input-wrapper">
                    <input type="number" name="CACHE_MAX_USAGE" value="<?= $ptc_cfg['CACHE_MAX_USAGE'] ?>" style="width: 100px;">
                    <span class="help-text"><?= $txt[$lang]['unit_percent'] ?></span>
                </div>
            </div>
            <div class="form-pair">
                <label><?= $txt[$lang]['smart'] ?></label>
                <div class="form-input-wrapper">
                    <input type="checkbox" name="ENABLE_SMART_CLEANUP" value="True" <?= $ptc_cfg['ENABLE_SMART_CLEANUP'] == 'True' ? 'checked' : '' ?> >
                </div>
            </div>
            <div class="form-pair">
                <label><?= $txt[$lang]['del_delay'] ?></label>
                <div class="form-input-wrapper">
                    <input type="number" name="MOVIE_DELETE_DELAY" value="<?= $ptc_cfg['MOVIE_DELETE_DELAY'] ?>" style="width: 100px;">
                    <span class="help-text"><?= $txt[$lang]['unit_sec'] ?></span>
                </div>
            </div>
            <div class="form-pair">
                <label><?= $txt[$lang]['keep'] ?></label>
                <div class="form-input-wrapper">
                    <input type="number" name="EPISODE_KEEP_PREVIOUS" value="<?= $ptc_cfg['EPISODE_KEEP_PREVIOUS'] ?>" style="width: 100px;">
                    <span class="help-text"><?= $txt[$lang]['unit_count'] ?></span>
                </div>
            </div>

        </form>
    </div>

    <!-- RIGHT COLUMN: LOGS -->
    <div id="ptc-log-container">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 15px;">
            <h3 style="margin:0; color:var(--primary-blue);"><i class="fa fa-terminal"></i> <?= $txt[$lang]['log'] ?></h3>
            <button class="btn-add" onclick="location.reload();" style="margin:0;">Refresh</button>
        </div>
        <div id="ptc-log">
            <?php
            if (file_exists($ptc_log_file)) {
                $output = shell_exec("tail -n 100 " . escapeshellarg($ptc_log_file));
                if (empty($output)) {
                    echo "Log file exists but is empty. Service starting...";
                } else {
                    echo nl2br(htmlspecialchars((string)$output));
                }
            } else {
                echo "Log file not found at $ptc_log_file. Service might be stopped or starting...";
            }
            ?>
        </div>
    </div>

</div>

<script>
function addMappingRow(dockerVal = '', hostVal = '') {
    var table = document.getElementById('mapping_table').getElementsByTagName('tbody')[0];
    var row = table.insertRow(-1);
    var cell1 = row.insertCell(0);
    var cell2 = row.insertCell(1);
    var cell3 = row.insertCell(2);
    
    cell1.innerHTML = '<input type="text" name="mapping_docker[]" value="' + dockerVal + '" placeholder="/movies" style="width:100%; background:#111; border:1px solid var(--primary-blue); color:#fff; padding:6px; border-radius:4px;" autocomplete="off">';
    cell2.innerHTML = '<input type="text" name="mapping_host[]" value="' + hostVal + '" placeholder="/mnt/user/Media/Movies" style="width:100%; background:#111; border:1px solid var(--primary-blue); color:#fff; padding:6px; border-radius:4px;" autocomplete="off">';
    cell3.innerHTML = '<a href="#" onclick="deleteRow(this); return false;" style="color:#ff4444; font-size:18px;"><i class="fa fa-minus-circle"></i></a>';
    cell3.style.textAlign = "center";
}

function deleteRow(btn) {
    var row = btn.parentNode.parentNode;
    row.parentNode.removeChild(row);
}

// Init rows
$(function() {
    <?php foreach ($mappings_pairs as $pair): ?>
    addMappingRow('<?= addslashes($pair[0]) ?>', '<?= addslashes($pair[1]) ?>');
    <?php endforeach; ?>
    // Don't add an empty row if we already have some
    if (document.getElementById('mapping_table').rows.length <= 1) {
        addMappingRow();
    }
});
</script>
]]>
</INLINE>
</FILE>

<FILE Name="/tmp/plex_to_cache_install/scripts/plex_to_cache.py">
<INLINE>
<![CDATA[
#!/usr/bin/python3
import requests
import os
import shutil
import subprocess
import time
import sys
import re
import fcntl
import signal
from pathlib import Path

# ==========================================
# --- CONFIGURATION DEFAULTS ---
# ==========================================

CONFIG_FILE = "/boot/config/plugins/plex_to_cache/settings.cfg"
LOCK_FILE_PATH = "/tmp/media_cache_cleaner.lock"

# Hardcoded Perms Root (Physical Disks)
PERMS_ROOT = "/mnt/user0"

CONFIG = {
    "ENABLE_PLEX": "False",
    "PLEX_URL": "http://localhost:32400",
    "PLEX_TOKEN": "",
    
    "ENABLE_EMBY": "False",
    "EMBY_URL": "http://localhost:8096",
    "EMBY_API_KEY": "",
    
    "ENABLE_JELLYFIN": "False",
    "JELLYFIN_URL": "http://localhost:8096",
    "JELLYFIN_API_KEY": "",
    
    "CHECK_INTERVAL": "10",
    "CACHE_MAX_USAGE": "80",
    "COPY_DELAY": "30",
    "ENABLE_SMART_CLEANUP": "False",
    "MOVIE_DELETE_DELAY": "1800",
    "EPISODE_KEEP_PREVIOUS": "2",
    "EXCLUDE_DIRS": "",
    "MEDIA_FILETYPES": ".mkv .mp4 .avi",
    "ARRAY_ROOT": "/mnt/user",
    "CACHE_ROOT": "/mnt/cache",
    "DOCKER_MAPPINGS": "" 
}

# --- INTERNE VARIABLES ---
movie_deletion_queue = {}
stream_start_times = {} 
metadata_path_cache = {} 
parsed_docker_mappings = {}

# ---------------------

def log_info(msg):
    print(msg, flush=True)

def parse_docker_mappings(mapping_str):
    mappings = {}
    if not mapping_str:
        return mappings
    # Format: docker:host;docker:host
    pairs = mapping_str.split(';')
    for pair in pairs:
        if ':' in pair:
            k, v = pair.split(':', 1)
            mappings[k.strip()] = v.strip()
    return mappings

def load_config():
    global CONFIG, parsed_docker_mappings
    log_info(f"Lade Konfiguration von {CONFIG_FILE}...")
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r') as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith("#"): continue
                    if "=" in line:
                        key, value = line.split("=", 1)
                        key = key.strip()
                        value = value.strip().strip('"').strip("'")
                        CONFIG[key] = value
        except Exception as e:
            log_info(f"[Error] Konnte Config nicht laden: {e}")
    
    parsed_docker_mappings = parse_docker_mappings(CONFIG.get("DOCKER_MAPPINGS", ""))
    log_info("Konfiguration geladen.")

def get_config_bool(key):
    val = CONFIG.get(key, "False")
    return val.lower() == "true" or val == "1"

def get_config_int(key):
    try: return int(CONFIG.get(key, 0))
    except: return 0

def acquire_lock():
    global lock_file
    lock_file = open(LOCK_FILE_PATH, 'w')
    try:
        fcntl.lockf(lock_file, fcntl.LOCK_EX | fcntl.LOCK_NB)
    except IOError:
        print("[Error] Skript läuft bereits! Beende diese Instanz.", flush=True)
        sys.exit(1)

# --- RECHTE LOGIK (USER0) ---

def get_perms_reference_path(cache_path):
    CACHE_ROOT = CONFIG["CACHE_ROOT"]
    if cache_path.startswith(CACHE_ROOT):
        return cache_path.replace(CACHE_ROOT, PERMS_ROOT, 1)
    return None

def clone_rights_from_disk(dst_path):
    src_path = get_perms_reference_path(dst_path)
    if not src_path or not os.path.exists(src_path):
        return 
    try:
        st = os.stat(src_path)
        os.chown(dst_path, st.st_uid, st.st_gid)
        os.chmod(dst_path, st.st_mode)
    except Exception as e:
        log_info(f"[Perms Error] Fehler bei {dst_path}: {e}")

# --- RESTLICHE FUNKTIONEN ---

def is_excluded(path):
    EXCLUDE_DIRS = CONFIG["EXCLUDE_DIRS"]
    if not EXCLUDE_DIRS: return False
    path_parts = path.split(os.sep)
    excludes = [x.strip() for x in EXCLUDE_DIRS.split(',')]
    for exc in excludes:
        if exc and exc in path_parts: return True
    return False

def is_trigger_filetype(filename):
    MEDIA_FILETYPES = CONFIG["MEDIA_FILETYPES"]
    if not MEDIA_FILETYPES: return True 
    valid_exts = [x.strip().lower() for x in MEDIA_FILETYPES.split()]
    lower_name = filename.lower()
    for ext in valid_exts:
        if lower_name.endswith(ext): return True
    return False

# --- API CLIENTS ---

def plex_api_get(endpoint):
    PLEX_URL = CONFIG["PLEX_URL"]
    PLEX_TOKEN = CONFIG["PLEX_TOKEN"]
    headers = {'X-Plex-Token': PLEX_TOKEN, 'Accept': 'application/json'}
    try:
        r = requests.get(f"{PLEX_URL}{endpoint}", headers=headers, timeout=5, verify=False)
        r.raise_for_status()
        return r.json()
    except Exception: return None

def emby_api_get(endpoint):
    EMBY_URL = CONFIG["EMBY_URL"]
    EMBY_API_KEY = CONFIG["EMBY_API_KEY"]
    headers = {'X-Emby-Token': EMBY_API_KEY, 'Accept': 'application/json'}
    try:
        r = requests.get(f"{EMBY_URL}{endpoint}", headers=headers, timeout=5, verify=False)
        r.raise_for_status()
        return r.json()
    except Exception: return None

def jellyfin_api_get(endpoint):
    # Jellyfin uses same API structure as Emby usually, but lets keep distinct config
    JELLYFIN_URL = CONFIG["JELLYFIN_URL"]
    JELLYFIN_API_KEY = CONFIG["JELLYFIN_API_KEY"]
    headers = {'X-Emby-Token': JELLYFIN_API_KEY, 'Accept': 'application/json'} # Jellyfin often accepts X-Emby-Token or X-MediaBrowser-Token
    try:
        r = requests.get(f"{JELLYFIN_URL}{endpoint}", headers=headers, timeout=5, verify=False)
        r.raise_for_status()
        return r.json()
    except Exception: return None

def check_connection():
    ok = True
    if get_config_bool("ENABLE_PLEX"):
        log_info(f"[Init] Teste Plex ({CONFIG['PLEX_URL']})...")
        if plex_api_get("/identity"): log_info("-> Plex OK")
        else: 
            log_info("[Error] Plex Fehler!")
            ok = False
    
    if get_config_bool("ENABLE_EMBY"):
        log_info(f"[Init] Teste Emby ({CONFIG['EMBY_URL']})...") 
        if emby_api_get("/System/Info"): log_info("-> Emby OK")
        else: 
            log_info("[Error] Emby Fehler!")
            ok = False

    if get_config_bool("ENABLE_JELLYFIN"):
        log_info(f"[Init] Teste Jellyfin ({CONFIG['JELLYFIN_URL']})...") 
        if jellyfin_api_get("/System/Info"): log_info("-> Jellyfin OK")
        else: 
            log_info("[Error] Jellyfin Fehler!")
            ok = False
    return ok

# --- SESSION HANDLING ---

def get_active_sessions():
    active_items = {}
    
    # PLEX
    if get_config_bool("ENABLE_PLEX"):
        data = plex_api_get("/status/sessions")
        if data and 'MediaContainer' in data and 'Metadata' in data['MediaContainer']:
            for item in data['MediaContainer']['Metadata']:
                rating_key = item.get('ratingKey')
                found_file = None
                if rating_key in metadata_path_cache:
                    found_file = metadata_path_cache[rating_key]
                if not found_file and 'Media' in item:
                    for media in item['Media']:
                        if 'Part' in media:
                            for part in media['Part']:
                                if part.get('file'): found_file = part.get('file'); break
                if not found_file and rating_key:
                    meta = plex_api_get(f"/library/metadata/{rating_key}")
                    if meta and 'MediaContainer' in meta and 'Metadata' in meta['MediaContainer']:
                        m = meta['MediaContainer']['Metadata'][0]
                        if 'Media' in m:
                            for media in m['Media']:
                                if 'Part' in media:
                                    for part in media['Part']:
                                        if part.get('file'): found_file = part.get('file'); break
                if found_file:
                    metadata_path_cache[rating_key] = found_file
                    active_items[found_file] = {'service': 'plex', 'id': rating_key}
    
    # EMBY
    if get_config_bool("ENABLE_EMBY"):
        data = emby_api_get("/Sessions")
        if data:
            for s in data:
                if 'NowPlayingItem' in s:
                    item = s['NowPlayingItem']
                    path = item.get('Path')
                    if path:
                        active_items[path] = {'service': 'emby', 'id': item.get('Id'), 'user': s.get('UserId')}

    # JELLYFIN
    if get_config_bool("ENABLE_JELLYFIN"):
        data = jellyfin_api_get("/Sessions")
        if data:
            for s in data:
                if 'NowPlayingItem' in s:
                    item = s['NowPlayingItem']
                    path = item.get('Path')
                    if path:
                        active_items[path] = {'service': 'jellyfin', 'id': item.get('Id'), 'user': s.get('UserId')}
    
    return active_items

def check_is_watched(session_data):
    if not session_data: return False
    service = session_data.get('service')
    
    if service == 'plex':
        r_key = session_data.get('id')
        data = plex_api_get(f"/library/metadata/{r_key}")
        if data and 'MediaContainer' in data and 'Metadata' in data['MediaContainer']:
            meta = data['MediaContainer']['Metadata'][0]
            if 'viewCount' in meta and meta['viewCount'] > 0: return True
            
    elif service == 'emby':
        item_id = session_data.get('id')
        user_id = session_data.get('user')
        if item_id and user_id:
            data = emby_api_get(f"/Users/{user_id}/Items/{item_id}")
            if data and 'UserData' in data: return data['UserData'].get('Played', False)

    elif service == 'jellyfin':
        item_id = session_data.get('id')
        user_id = session_data.get('user')
        if item_id and user_id:
            data = jellyfin_api_get(f"/Users/{user_id}/Items/{item_id}")
            if data and 'UserData' in data: return data['UserData'].get('Played', False)
            
    return False

# --- PFAD TOOLS ---

def translate_path(docker_path):
    clean_path = docker_path.replace('\\', '/')
    ARRAY_ROOT = CONFIG["ARRAY_ROOT"]
    
    for d_prefix, real_prefix in parsed_docker_mappings.items():
        if clean_path.startswith(d_prefix):
            rel_path = clean_path[len(d_prefix):]
            if not rel_path.startswith('/'): rel_path = '/' + rel_path
            final_path = f"{ARRAY_ROOT}{real_prefix}{rel_path}"
            return final_path.replace('//', '/')
    if clean_path.startswith("/mnt/"): return clean_path
    return docker_path

def get_cache_path(array_path):
    ARRAY_ROOT = CONFIG["ARRAY_ROOT"]
    CACHE_ROOT = CONFIG["CACHE_ROOT"]
    if array_path.startswith(ARRAY_ROOT): return array_path.replace(ARRAY_ROOT, CACHE_ROOT, 1)
    return None

def parse_episode_number(filename):
    match = re.search(r"[sS]\d+[eE](\d+)", filename)
    if match: return int(match.group(1))
    return None

def is_last_episode_on_array(file_path):
    try:
        ep_num = parse_episode_number(os.path.basename(file_path))
        if ep_num is None: return False
        folder = os.path.dirname(file_path)
        max_ep = 0
        if os.path.exists(folder):
            for f in os.listdir(folder):
                e = parse_episode_number(f)
                if e and e > max_ep: max_ep = e
        return ep_num >= max_ep
    except: return False

# --- MOVER / DELETE LOGIC (UPDATED) ---

def cleanup_empty_parent_dirs(path):
    parent_dir = os.path.dirname(path)
    CACHE_ROOT = CONFIG["CACHE_ROOT"]
    protected = [os.path.join(CACHE_ROOT, m.strip("/")) for m in parsed_docker_mappings.values()]
    while parent_dir.startswith(CACHE_ROOT) and len(parent_dir) > len(CACHE_ROOT):
        if parent_dir in protected: break
        try:
            os.rmdir(parent_dir)
            parent_dir = os.path.dirname(parent_dir)
        except OSError: break

def move_to_array(cache_path):
    CACHE_ROOT = CONFIG["CACHE_ROOT"]
    # PERMS_ROOT is constant now
    
    rel_path = cache_path.replace(CACHE_ROOT, "").lstrip("/")
    dest_path = os.path.join(PERMS_ROOT, rel_path)
    
    log_info(f"[Mover] Verschiebe nach Array: {os.path.basename(cache_path)}")
    
    try:
        dest_dir = os.path.dirname(dest_path)
        if not os.path.exists(dest_dir):
            os.makedirs(dest_dir, exist_ok=True)
            clone_rights_from_disk(os.path.dirname(cache_path).replace(CACHE_ROOT, CACHE_ROOT)) 

        cmd = ["rsync", "-a", "--remove-source-files", cache_path, dest_path]
        subprocess.run(cmd, check=True, stdout=subprocess.DEVNULL)
        
        cleanup_empty_parent_dirs(cache_path)
        log_info(f"[Mover] Erfolgreich verschoben.")
        
    except Exception as e:
        log_info(f"[Error] Mover fehlgeschlagen: {e}")

def smart_manage_cache_file(cache_path, reason="Cleanup"):
    if not os.path.exists(cache_path): return
    
    CACHE_ROOT = CONFIG["CACHE_ROOT"]
    # PERMS_ROOT is constant

    rel_path = cache_path.replace(CACHE_ROOT, "").lstrip("/")
    array_path = os.path.join(PERMS_ROOT, rel_path)
    
    if os.path.exists(array_path):
        try:
            if os.path.getsize(cache_path) == os.path.getsize(array_path):
                os.remove(cache_path)
                log_info(f"[{reason}] Gelöscht (Duplikat): {os.path.basename(cache_path)}")
                cleanup_empty_parent_dirs(cache_path)
        except OSError: pass
    else:
        move_to_array(cache_path)

def ensure_directory_structure_mirror(full_cache_file_path):
    CACHE_ROOT = CONFIG["CACHE_ROOT"]
    target_dir = os.path.dirname(full_cache_file_path)
    try: rel_path = os.path.relpath(target_dir, CACHE_ROOT)
    except ValueError: return 
    current_cache_path = CACHE_ROOT
    path_parts = rel_path.split(os.sep)
    for part in path_parts:
        if part == "." or not part: continue
        current_cache_path = os.path.join(current_cache_path, part)
        if not os.path.exists(current_cache_path):
            try: os.mkdir(current_cache_path)
            except OSError: pass
        clone_rights_from_disk(current_cache_path)

def cache_file_if_needed(source_path):
    ARRAY_ROOT = CONFIG["ARRAY_ROOT"]
    CACHE_ROOT = CONFIG["CACHE_ROOT"]
    
    rel_path = source_path.replace(ARRAY_ROOT, "")
    if rel_path.startswith("/"): rel_path = rel_path[1:]
    if is_excluded(rel_path): return

    try:
        usage = shutil.disk_usage(CACHE_ROOT)
        if (usage.used / usage.total) * 100 >= get_config_int("CACHE_MAX_USAGE"): return
    except: return

    dest_path = os.path.join(CACHE_ROOT, rel_path)
    
    if os.path.exists(dest_path):
        try:
            if os.path.getsize(source_path) == os.path.getsize(dest_path):
                if dest_path in movie_deletion_queue: del movie_deletion_queue[dest_path]
                return
        except: pass

    log_info(f"[Copy] Starte: {os.path.basename(source_path)}")
    try:
        ensure_directory_structure_mirror(dest_path)
        cmd = ["rsync", "-a", source_path, dest_path]
        subprocess.run(cmd, check=True, stdout=subprocess.DEVNULL)
        clone_rights_from_disk(dest_path)
        log_info(f"[Copy] Fertig: {os.path.basename(source_path)}")
    except Exception as e:
        log_info(f"[Error] Copy failed: {e}")

# --- HANDLER ---

def handle_series_logic_smart(playing_real_path):
    filename = os.path.basename(playing_real_path)
    current_ep = parse_episode_number(filename)
    if current_ep is None:
        handle_movie_logic(playing_real_path)
        return

    season_dir_array = os.path.dirname(playing_real_path)
    season_dir_cache = get_cache_path(season_dir_array)

    if get_config_bool("ENABLE_SMART_CLEANUP") and season_dir_cache and os.path.exists(season_dir_cache):
        threshold_ep = current_ep - get_config_int("EPISODE_KEEP_PREVIOUS")
        for f in os.listdir(season_dir_cache):
            full_path = os.path.join(season_dir_cache, f)
            if os.path.isfile(full_path):
                ep_num = parse_episode_number(f)
                if ep_num is not None and ep_num < threshold_ep:
                    smart_manage_cache_file(full_path, reason="Smart Cleanup")

    candidates = []
    try:
        if os.path.exists(season_dir_array):
            for f in os.listdir(season_dir_array):
                full_path = os.path.join(season_dir_array, f)
                if not os.path.isfile(full_path): continue
                ep_num = parse_episode_number(f)
                if ep_num is not None and ep_num >= current_ep:
                    candidates.append((ep_num, full_path))
            for _, path in sorted(candidates, key=lambda x: x[0]):
                cache_file_if_needed(path)
    except OSError: pass

def handle_movie_logic(movie_real_path):
    cache_file_if_needed(movie_real_path)
    try:
        folder = os.path.dirname(movie_real_path)
        basename = os.path.basename(movie_real_path)
        stem = os.path.splitext(basename)[0] 
        if os.path.exists(folder):
            for f in os.listdir(folder):
                if f == basename: continue 
                if f.startswith(stem):
                    full_path = os.path.join(folder, f)
                    if os.path.isfile(full_path):
                        cache_file_if_needed(full_path)
    except: pass

def handle_movie_cleanup_smart(active_paths):
    if not get_config_bool("ENABLE_SMART_CLEANUP"): return
    current_time = time.time()
    for movie in active_paths:
        cache_path = get_cache_path(movie)
        if cache_path in movie_deletion_queue:
            del movie_deletion_queue[cache_path]
    for cache_path, timestamp in list(movie_deletion_queue.items()):
        if current_time - timestamp > get_config_int("MOVIE_DELETE_DELAY"):
            smart_manage_cache_file(cache_path, reason="Deletion Timer")
            del movie_deletion_queue[cache_path]

# --- MAIN LOOP ---
if __name__ == "__main__":
    load_config()
    acquire_lock()
    
    signal.signal(signal.SIGHUP, lambda signum, frame: load_config())

    try: requests.packages.urllib3.disable_warnings() 
    except: pass
    
    stream_start_times = {} 
    last_loop_sessions = {}

    log_info(f"Starte Media Cache Manager (Plex & Emby & Jellyfin)...")
    if not check_connection(): log_info("[Warning] Nicht alle Dienste erreichbar.")

    try:
        while True:
            current_sessions = get_active_sessions()
            active_real_paths = []
            
            for docker_path, session_data in current_sessions.items():
                real_path = translate_path(docker_path)
                if not real_path.startswith(CONFIG["ARRAY_ROOT"]): continue
                if is_excluded(real_path): continue
                if not is_trigger_filetype(os.path.basename(real_path)): continue

                active_real_paths.append(real_path)
                
                COPY_DELAY = get_config_int("COPY_DELAY")
                if real_path not in stream_start_times:
                    log_info(f"[Delay] Neuer Stream: {os.path.basename(real_path)} (Warte {COPY_DELAY}s)")
                    stream_start_times[real_path] = time.time()
                    continue 
                if time.time() - stream_start_times[real_path] < COPY_DELAY: continue
                
                ep_check = parse_episode_number(os.path.basename(real_path))
                if ep_check is not None: handle_series_logic_smart(real_path)
                else: handle_movie_logic(real_path) 

            for path in list(stream_start_times.keys()):
                if path not in set(active_real_paths): del stream_start_times[path]

            if get_config_bool("ENABLE_SMART_CLEANUP"):
                stopped_docker_paths = set(last_loop_sessions.keys()) - set(current_sessions.keys())
                for d_path in stopped_docker_paths:
                    session_data = last_loop_sessions.get(d_path)
                    real_path = translate_path(d_path)
                    if is_excluded(real_path): continue
                    
                    if parse_episode_number(os.path.basename(real_path)) is None:
                        if check_is_watched(session_data):
                            log_info(f"[Gesehen] {os.path.basename(real_path)} -> Timer Start")
                            c_path = get_cache_path(real_path)
                            if c_path and os.path.exists(c_path): movie_deletion_queue[c_path] = time.time()
                    else:
                        if check_is_watched(session_data):
                             if is_last_episode_on_array(real_path):
                                log_info(f"[Gesehen] Staffel-Finale: {os.path.basename(real_path)} -> Timer für Rest")
                                season_cache_dir = get_cache_path(os.path.dirname(real_path))
                                if season_cache_dir and os.path.exists(season_cache_dir):
                                    for f in os.listdir(season_cache_dir):
                                        full_p = os.path.join(season_cache_dir, f)
                                        if os.path.isfile(full_p): movie_deletion_queue[full_p] = time.time()
                handle_movie_cleanup_smart(active_real_paths)

            last_loop_sessions = current_sessions
            time.sleep(get_config_int("CHECK_INTERVAL"))
            
    except KeyboardInterrupt:
        print("Beende Skript...", flush=True)
        sys.exit(0)
]]>
</INLINE>
</FILE>

<FILE Name="/tmp/plex_to_cache_install/scripts/rc.plex_to_cache">
<INLINE>
<![CDATA[
#!/bin/bash

PYTHON_SCRIPT="/usr/local/emhttp/plugins/plex_to_cache/scripts/plex_to_cache.py"
PID_FILE="/var/run/plex_to_cache.pid"
LOG_FILE="/var/log/plex_to_cache.log"

start() {
    if [ -f "$PID_FILE" ]; then
        if ps -p $(cat "$PID_FILE") > /dev/null; then
            echo "Service already running."
            return
        fi
    fi
    echo "Starting Plex to Cache Service..."
    nohup python3 "$PYTHON_SCRIPT" > "$LOG_FILE" 2>&1 &
    echo $! > "$PID_FILE"
    echo "Service started."
}

stop() {
    if [ -f "$PID_FILE" ]; then
        PID=$(cat "$PID_FILE")
        if ps -p "$PID" > /dev/null; then
            echo "Stopping Service..."
            kill "$PID"
            rm "$PID_FILE"
            echo "Service stopped."
        else
            echo "Service not running (stale PID file)."
            rm "$PID_FILE"
        fi
    else
        echo "Service not running."
    fi
}

restart() {
    stop
    sleep 1
    start
}

status() {
    if [ -f "$PID_FILE" ]; then
        if ps -p $(cat "$PID_FILE") > /dev/null; then
            echo "Service is running."
        else
            echo "Service is stopped (stale PID)."
        fi
    else
        echo "Service is stopped."
    fi
}

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    restart)
        restart
        ;;
    status)
        status
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|status}"
        exit 1
esac
]]>
</INLINE>
</FILE>

<FILE Run="/bin/bash">
<INLINE>
<![CDATA[
# Dependencies
if ! python3 -c "import requests" 2>/dev/null; then
    curl -s https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py
    python3 /tmp/get-pip.py >/dev/null 2>&1
    pip3 install requests >/dev/null 2>&1
fi

# 1. Stop old Service
pkill -9 -f plex_to_cache.py 2>/dev/null

# 2. Cleanup Old Installation (THIS was the bug source before, now handled safely)
rm -rf /usr/local/emhttp/plugins/plex_to_cache
mkdir -p /usr/local/emhttp/plugins/plex_to_cache/scripts

# 3. Move New Files from Temp to Live
mv /tmp/plex_to_cache_install/plex_to_cache.page /usr/local/emhttp/plugins/plex_to_cache/
mv /tmp/plex_to_cache_install/plex_to_cache.php /usr/local/emhttp/plugins/plex_to_cache/
mv /tmp/plex_to_cache_install/scripts/* /usr/local/emhttp/plugins/plex_to_cache/scripts/

# 4. Cleanup Temp
rm -rf /tmp/plex_to_cache_install

# 5. Permissions
chmod +x /usr/local/emhttp/plugins/plex_to_cache/scripts/rc.plex_to_cache
chmod +x /usr/local/emhttp/plugins/plex_to_cache/scripts/plex_to_cache.py

# 6. Config Directory
mkdir -p /boot/config/plugins/plex_to_cache

# 7. Logs
touch /var/log/plex_to_cache.log
chmod 666 /var/log/plex_to_cache.log

# 8. Start Service
/usr/local/emhttp/plugins/plex_to_cache/scripts/rc.plex_to_cache restart
echo "Plex to Cache v2025.12.30.04 installed."
]]>
</INLINE>
</FILE>

</PLUGIN>