<?xml version='1.0' standalone='yes'?>
<!DOCTYPE PLUGIN [
<!ENTITY name      "plex_to_cache">
<!ENTITY author    "MajorPain007">
<!ENTITY version   "2025.12.30u">
<!ENTITY launch    "Utilities/plex_to_cache">
<!ENTITY pluginURL "https://raw.githubusercontent.com/MajorPain007/unraid-move-to-cache/main/plex_to_cache.plg">
]>
<PLUGIN name="&name;" author="&author;" version="&version;" launch="&launch;" pluginURL="&pluginURL;">

<FILE Name="/usr/local/emhttp/plugins/&name;/log.php">
<INLINE>
<![CDATA[
<?php
$log_file = "/var/log/plex_to_cache.log";
if (file_exists($log_file)) {
    echo shell_exec("tail -n 200 " . escapeshellarg($log_file));
} else { echo "Warte auf Dienst-Start..."; }
?>
]]>
</INLINE>
</FILE>

<FILE Name="/usr/local/emhttp/plugins/&name;/plex_to_cache.page">
<INLINE>
<![CDATA[
Menu="Utilities"
Icon="server"
Title="Plex to Cache"
---
<?php include '/usr/local/emhttp/plugins/plex_to_cache/plex_to_cache.php'; ?>
]]>
</INLINE>
</FILE>

<FILE Name="/usr/local/emhttp/plugins/&name;/plex_to_cache.php">
<INLINE>
<![CDATA[
<?php
$ptc_plugin = "plex_to_cache";
$ptc_cfg_file = "/boot/config/plugins/$ptc_plugin/settings.cfg";

$ptc_cfg = [
    "ENABLE_PLEX" => "True", "PLEX_URL" => "http://192.168.20.3:32400", "PLEX_TOKEN" => "",
    "ENABLE_EMBY" => "False", "EMBY_URL" => "http://192.168.20.3:8097", "EMBY_API_KEY" => "",
    "ENABLE_JELLYFIN" => "False", "JELLYFIN_URL" => "http://192.168.20.3:8097", "JELLYFIN_API_KEY" => "",
    "CHECK_INTERVAL" => "10", "CACHE_MAX_USAGE" => "80", "COPY_DELAY" => "30",
    "ENABLE_SMART_CLEANUP" => "False", "MOVIE_DELETE_DELAY" => "1800", "EPISODE_KEEP_PREVIOUS" => "2",
    "EXCLUDE_DIRS" => "", "MEDIA_FILETYPES" => ".mkv .mp4 .avi", "ARRAY_ROOT" => "/mnt/user",
    "CACHE_ROOT" => "/mnt/cache", "DOCKER_MAPPINGS" => "/Media:/media"
];

if (file_exists($ptc_cfg_file)) {
    $ptc_loaded = parse_ini_file($ptc_cfg_file);
    if ($ptc_loaded) { $ptc_cfg = array_merge($ptc_cfg, $ptc_loaded); }
}

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    foreach ($ptc_cfg as $key => $val) {
        if (isset($_POST[$key])) { $ptc_cfg[$key] = $_POST[$key]; }
        else { if (strpos($key, "ENABLE_") === 0 || $key === "ENABLE_SMART_CLEANUP") { $ptc_cfg[$key] = "False"; } }
    }
    $m_str = "";
    if (isset($_POST['mapping_host']) && isset($_POST['mapping_docker'])) {
        $h_arr = $_POST['mapping_host']; $d_arr = $_POST['mapping_docker']; $pairs = [];
        for ($i=0; $i<count($h_arr); $i++) {
            if (!empty(trim($h_arr[$i]))) { $pairs[] = trim($h_arr[$i]).":".trim($d_arr[$i]); }
        }
        $m_str = implode(";", $pairs);
    }
    $ptc_cfg['DOCKER_MAPPINGS'] = $m_str;
    $content = "";
    foreach ($ptc_cfg as $key => $val) { $content .= "$key=\"$val\"\n"; }
    if (!is_dir(dirname($ptc_cfg_file))) mkdir(dirname($ptc_cfg_file), 0777, true);
    file_put_contents($ptc_cfg_file, $content);
    shell_exec("/usr/local/emhttp/plugins/plex_to_cache/scripts/rc.plex_to_cache restart");
    $save_msg = "Einstellungen gespeichert & Dienst neugestartet.";
}

$mappings_pairs = [];
if (!empty($ptc_cfg['DOCKER_MAPPINGS'])) {
    $pairs = explode(";", $ptc_cfg['DOCKER_MAPPINGS']);
    foreach ($pairs as $p) { if (strpos($p, ":") !== false) { $mappings_pairs[] = explode(":", $p, 2); } }
}
?>
<style>
:root { --primary-blue: #00aaff; --bg-dark: #111; }
#ptc-wrapper { display: flex; flex-wrap: nowrap; align-items: flex-start; justify-content: space-between; gap: 20px; width: 100%; box-sizing: border-box; }
#ptc-settings, #ptc-log-container { background: var(--bg-dark); border-radius: 12px; box-shadow: 0 0 12px rgba(0, 170, 255, 0.2); color: #f0f8ff; padding: 20px; box-sizing: border-box; }
#ptc-settings { flex: 0 0 48%; }
#ptc-log-container { flex: 0 0 50%; display: flex; flex-direction: column; min-height: 850px; }
.section-header { color: var(--primary-blue); font-size: 18px; font-weight: bold; margin-bottom: 15px; margin-top: 25px; border-bottom: 1px solid #333; padding-bottom: 5px; }
.form-pair { display: flex; align-items: center; margin-bottom: 15px; gap: 10px; }
.form-pair label { flex: 0 0 140px; color: var(--primary-blue); font-weight: bold; font-size: 14px; }
.form-input-wrapper { flex: 1; display: flex; align-items: center; }
.form-input-wrapper input[type="text"], .form-input-wrapper input[type="password"], .form-input-wrapper input[type="number"] { background: #111; border: 1px solid var(--primary-blue); border-radius: 5px; color: #fff; padding: 8px; width: 100%; box-sizing: border-box; }
.form-input-wrapper input[type="checkbox"] { accent-color: var(--primary-blue); width: 18px; height: 18px; cursor: pointer; }
#ptc-log { background: #000; border: 1px solid var(--primary-blue); border-radius: 8px; color: #00ffaa; font-family: monospace; font-size: 12px; padding: 15px; flex-grow: 1; overflow-y: auto; white-space: pre-wrap; word-break: break-all; margin-top: 10px; line-height: 1.4; }
.status-msg { background: rgba(46, 204, 64, 0.1); color: #2ECC40; padding: 10px; border-radius: 6px; margin-bottom: 20px; border: 1px solid #2ECC40; text-align: center; font-weight: bold; }
@media (max-width: 1100px) { #ptc-wrapper { flex-wrap: wrap; } #ptc-settings, #ptc-log-container { flex: 1 1 100%; } }
</style>
<div id="ptc-wrapper">
    <div id="ptc-settings">
        <form method="post" autocomplete="off">
            <?php if (isset($save_msg)) echo "<div class='status-msg'>$save_msg</div>"; ?>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin:0; color:var(--primary-blue);">Einstellungen</h2>
                <input type="submit" value="Speichern & Übernehmen" style="background:var(--primary-blue); color:#fff; border:none; padding:10px 20px; border-radius:4px; font-weight:bold; cursor:pointer;">
            </div>
            
            <div class="section-header">Plex Media Server</div>
            <div class="form-pair"><label>Aktivieren:</label><div class="form-input-wrapper"><input type="checkbox" name="ENABLE_PLEX" value="True" <?= $ptc_cfg['ENABLE_PLEX'] == 'True' ? 'checked' : '' ?> ></div></div>
            <div class="form-pair"><label>Plex URL:</label><div class="form-input-wrapper"><input type="text" name="PLEX_URL" value="<?= $ptc_cfg['PLEX_URL'] ?>" autocomplete="off"></div></div>
            <div class="form-pair"><label>Plex Token:</label><div class="form-input-wrapper"><input type="password" name="PLEX_TOKEN" value="<?= $ptc_cfg['PLEX_TOKEN'] ?>" onmouseover="this.type='text'" onmouseout="this.type='password'" autocomplete="new-password"></div></div>
            
            <div class="section-header">Emby Server</div>
            <div class="form-pair"><label>Aktivieren:</label><div class="form-input-wrapper"><input type="checkbox" name="ENABLE_EMBY" value="True" <?= $ptc_cfg['ENABLE_EMBY'] == 'True' ? 'checked' : '' ?> ></div></div>
            <div class="form-pair"><label>Emby URL:</label><div class="form-input-wrapper"><input type="text" name="EMBY_URL" value="<?= $ptc_cfg['EMBY_URL'] ?>" autocomplete="off"></div></div>
            <div class="form-pair"><label>Emby API Key:</label><div class="form-input-wrapper"><input type="password" name="EMBY_API_KEY" value="<?= $ptc_cfg['EMBY_API_KEY'] ?>" onmouseover="this.type='text'" onmouseout="this.type='password'" autocomplete="new-password"></div></div>
            
            <div class="section-header">Jellyfin Server</div>
            <div class="form-pair"><label>Aktivieren:</label><div class="form-input-wrapper"><input type="checkbox" name="ENABLE_JELLYFIN" value="True" <?= $ptc_cfg['ENABLE_JELLYFIN'] == 'True' ? 'checked' : '' ?> ></div></div>
            <div class="form-pair"><label>Jellyfin URL:</label><div class="form-input-wrapper"><input type="text" name="JELLYFIN_URL" value="<?= $ptc_cfg['JELLYFIN_URL'] ?>" autocomplete="off"></div></div>
            <div class="form-pair"><label>Jellyfin API Key:</label><div class="form-input-wrapper"><input type="password" name="JELLYFIN_API_KEY" value="<?= $ptc_cfg['JELLYFIN_API_KEY'] ?>" onmouseover="this.type='text'" onmouseout="this.type='password'" autocomplete="new-password"></div></div>
            
            <div class="section-header">Pfade</div>
            <div class="form-pair"><label>Array Root:</label><div class="form-input-wrapper"><input type="text" name="ARRAY_ROOT" value="<?= $ptc_cfg['ARRAY_ROOT'] ?>"></div></div>
            <div class="form-pair"><label>Cache Root:</label><div class="form-input-wrapper"><input type="text" name="CACHE_ROOT" value="<?= $ptc_cfg['CACHE_ROOT'] ?>"></div></div>
            
            <div class="section-header">Docker Pfad Mappings</div>
            <table id="mapping_table" style="width:100%;"><thead><tr><th style="color:var(--primary-blue);text-align:left;">Host Path (Unraid)</th><th style="color:var(--primary-blue);text-align:left;">Docker Path (Container)</th><th></th></tr></thead><tbody></tbody></table>
            <button type="button" onclick="addMappingRow()" style="background:transparent; color:var(--primary-blue); border:1px solid var(--primary-blue); padding:5px 10px; border-radius:4px; cursor:pointer; margin-top:10px;">+ Mapping hinzufügen</button>
            
            <div class="section-header">Tuning & Cleanup</div>
            <div class="form-pair"><label>Check Intervall:</label><div class="form-input-wrapper"><input type="number" name="CHECK_INTERVAL" value="<?= $ptc_cfg['CHECK_INTERVAL'] ?>" style="width: 80px;"><span style="margin-left:8px;font-style:italic;color:#888;">sek</span></div></div>
            <div class="form-pair"><label>Kopier Verzögerung:</label><div class="form-input-wrapper"><input type="number" name="COPY_DELAY" value="<?= $ptc_cfg['COPY_DELAY'] ?>" style="width: 80px;"><span style="margin-left:8px;font-style:italic;color:#888;">sek</span></div></div>
            <div class="form-pair"><label>Smart Cleanup:</label><div class="form-input-wrapper"><input type="checkbox" name="ENABLE_SMART_CLEANUP" value="True" <?= $ptc_cfg['ENABLE_SMART_CLEANUP'] == 'True' ? 'checked' : '' ?> ></div></div>
            <div class="form-pair"><label>Lösch Verzögerung:</label><div class="form-input-wrapper"><input type="number" name="MOVIE_DELETE_DELAY" value="<?= $ptc_cfg['MOVIE_DELETE_DELAY'] ?>" style="width: 80px;"><span style="margin-left:8px;font-style:italic;color:#888;">sek</span></div></div>
            <div class="form-pair"><label>Episoden behalten:</label><div class="form-input-wrapper"><input type="number" name="EPISODE_KEEP_PREVIOUS" value="<?= $ptc_cfg['EPISODE_KEEP_PREVIOUS'] ?>" style="width: 80px;"><span style="margin-left:8px;font-style:italic;color:#888;">Stk</span></div></div>
        </form>
    </div>
    <div id="ptc-log-container">
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h3 style="margin:0; color:var(--primary-blue); font-size:18px; font-weight:bold;"><i class="fa fa-terminal"></i> Log Auswertung</h3>
            <div style="display:flex; align-items:center; gap:10px;">
                <label style="color:#888; font-size:12px; cursor:pointer;"><input type="checkbox" id="auto_refresh" checked> Auto Refresh</label>
                <button onclick="refreshLog();" style="background:transparent; color:var(--primary-blue); border:1px solid var(--primary-blue); padding:5px 10px; border-radius:4px; cursor:pointer;">Refresh</button>
            </div>
        </div>
        <div id="ptc-log">Lade Logs...</div>
    </div>
</div>
<script>
function refreshLog() {
    $.get('/plugins/plex_to_cache/log.php', function(data) {
        var logDiv = $('#ptc-log');
        logDiv.text(data);
        logDiv.scrollTop(logDiv[0].scrollHeight);
    });
}
function addMappingRow(hostVal = '', dockerVal = '') {
    var table = document.getElementById('mapping_table').getElementsByTagName('tbody')[0];
    var row = table.insertRow(-1);
    var c1 = row.insertCell(0); var c2 = row.insertCell(1); var c3 = row.insertCell(2);
    c1.innerHTML = '<input type="text" name="mapping_host[]" value="' + hostVal + '" placeholder="/Media" style="width:100%; background:#111; border:1px solid var(--primary-blue); color:#fff; padding:6px; border-radius:4px;" autocomplete="off">';
    c2.innerHTML = '<input type="text" name="mapping_docker[]" value="' + dockerVal + '" placeholder="/media" style="width:100%; background:#111; border:1px solid var(--primary-blue); color:#fff; padding:6px; border-radius:4px;" autocomplete="off">';
    c3.innerHTML = '<a href="#" onclick="deleteRow(this); return false;" style="color:#ff4444; font-size:18px;"><i class="fa fa-minus-circle"></i></a>';
}
function deleteRow(btn) { var row = btn.parentNode.parentNode; row.parentNode.removeChild(row); }
$(function() {
    <?php foreach ($mappings_pairs as $p): ?> addMappingRow('<?= addslashes($p[0]) ?>', '<?= addslashes($p[1]) ?>'); <?php endforeach; ?>
    if (document.getElementById('mapping_table').rows.length <= 1) { addMappingRow(); }
    refreshLog();
    setInterval(function() { if ($('#auto_refresh').is(':checked')) refreshLog(); }, 3000);
});
</script>
]]>
</INLINE>
</FILE>

<FILE Name="/usr/local/emhttp/plugins/&name;/scripts/plex_to_cache.py">
<INLINE>
<![CDATA[
#!/usr/bin/python3
import requests, os, shutil, subprocess, time, sys, re, fcntl, signal
from pathlib import Path

CONFIG_FILE = "/boot/config/plugins/plex_to_cache/settings.cfg"
LOCK_FILE_PATH = "/tmp/media_cache_cleaner.lock"
PERMS_ROOT = "/mnt/user0" 

CONF = {}
parsed_docker_mappings = {}
movie_deletion_queue = {}
stream_start_times = {} 
metadata_path_cache = {} 

def log_info(msg):
    print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] {msg}", flush=True)

def load_plugin_config():
    global CONF, parsed_docker_mappings
    CONF = {
        "ENABLE_PLEX": "False", "PLEX_URL": "http://localhost:32400", "PLEX_TOKEN": "",
        "ENABLE_EMBY": "False", "EMBY_URL": "http://localhost:8096", "EMBY_API_KEY": "",
        "ENABLE_JELLYFIN": "False", "JELLYFIN_URL": "http://localhost:8096", "JELLYFIN_API_KEY": "",
        "CHECK_INTERVAL": "10", "CACHE_MAX_USAGE": "80", "COPY_DELAY": "30",
        "ENABLE_SMART_CLEANUP": "False", "MOVIE_DELETE_DELAY": "1800", "EPISODE_KEEP_PREVIOUS": "2",
        "EXCLUDE_DIRS": "", "MEDIA_FILETYPES": ".mkv .mp4 .avi", "ARRAY_ROOT": "/mnt/user",
        "CACHE_ROOT": "/mnt/cache", "DOCKER_MAPPINGS": ""
    }
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r') as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith("#") or "=" not in line: continue
                    k, v = line.split("=", 1)
                    CONF[k.strip()] = v.strip().strip('"').strip("'")
        except: pass
    
    parsed_docker_mappings.clear()
    m_str = CONF.get("DOCKER_MAPPINGS", "")
    if m_str:
        for pair in m_str.split(';'):
            if ':' in pair:
                hp, dp = pair.split(':', 1)
                parsed_docker_mappings[dp.strip()] = hp.strip()

def get_b(key): return CONF.get(key, "False").lower() in ["true", "1", "yes"]
def get_i(key):
    try: return int(CONF.get(key, 0))
    except: return 0

def get_perms_reference_path(cache_path):
    CACHE_ROOT = CONF["CACHE_ROOT"]
    if cache_path.startswith(CACHE_ROOT):
        return cache_path.replace(CACHE_ROOT, PERMS_ROOT, 1)
    return None

def clone_rights_from_disk(dst_path):
    src_path = get_perms_reference_path(dst_path)
    if not src_path or not os.path.exists(src_path): return 
    try:
        st = os.stat(src_path)
        os.chown(dst_path, st.st_uid, st.st_gid)
        os.chmod(dst_path, st.st_mode)
    except Exception as e:
        log_info(f"[Perms Error] {e}")

def ensure_directory_structure_mirror(full_cache_file_path):
    CACHE_ROOT = CONF["CACHE_ROOT"]
    target_dir = os.path.dirname(full_cache_file_path)
    try: rel_path = os.path.relpath(target_dir, CACHE_ROOT)
    except: return 
    current_cache_path = CACHE_ROOT
    for part in rel_path.split(os.sep):
        if not part or part == ".": continue
        current_cache_path = os.path.join(current_cache_path, part)
        if not os.path.exists(current_cache_path):
            try: os.mkdir(current_cache_path)
            except: pass
        clone_rights_from_disk(current_cache_path)

def plex_api_get(endpoint):
    headers = {'X-Plex-Token': CONF["PLEX_TOKEN"], 'Accept': 'application/json'}
    try:
        r = requests.get(f"{CONF['PLEX_URL']}{endpoint}", headers=headers, timeout=5, verify=False)
        return r.json()
    except: return None

def emby_api_get(endpoint, key, url):
    headers = {'X-Emby-Token': key, 'Accept': 'application/json'}
    try:
        r = requests.get(f"{url}{endpoint}", headers=headers, timeout=5, verify=False)
        return r.json()
    except: return None

def check_connection():
    if get_b("ENABLE_PLEX"):
        log_info(f"Teste Plex: {CONF['PLEX_URL']}")
        if plex_api_get("/identity"): log_info("-> Plex OK")
        else: log_info("-> Plex Fehler!")
    if get_b("ENABLE_EMBY"):
        log_info(f"Teste Emby: {CONF['EMBY_URL']}")
        if emby_api_get("/System/Info", CONF["EMBY_API_KEY"], CONF["EMBY_URL"]): log_info("-> Emby OK")
        else: log_info("-> Emby Fehler!")
    if get_b("ENABLE_JELLYFIN"):
        log_info(f"Teste Jellyfin: {CONF['JELLYFIN_URL']}")
        if emby_api_get("/System/Info", CONF["JELLYFIN_API_KEY"], CONF["JELLYFIN_URL"]): log_info("-> Jellyfin OK")
        else: log_info("-> Jellyfin Fehler!")

def get_active_sessions():
    active_items = {}
    if get_b("ENABLE_PLEX"):
        data = plex_api_get("/status/sessions")
        if data and 'MediaContainer' in data and 'Metadata' in data['MediaContainer']:
            for item in data['MediaContainer']['Metadata']:
                rating_key = item.get('ratingKey')
                found_file = None
                if rating_key in metadata_path_cache: found_file = metadata_path_cache[rating_key]
                if not found_file and 'Media' in item:
                    for media in item['Media']:
                        for part in media.get('Part', []):
                            if part.get('file'): found_file = part['file']; break
                if not found_file and rating_key:
                    meta = plex_api_get(f"/library/metadata/{rating_key}")
                    if meta and 'MediaContainer' in meta and 'Metadata' in meta['MediaContainer']:
                        for m in meta['MediaContainer']['Metadata']:
                            for med in m.get('Media', []):
                                for p in med.get('Part', []):
                                    if p.get('file'): found_file = p['file']; break
                if found_file:
                    metadata_path_cache[rating_key] = found_file
                    active_items[found_file] = {'service': 'plex', 'id': rating_key}
    
    for svc in [("ENABLE_EMBY", "EMBY_API_KEY", "EMBY_URL", "emby"), ("ENABLE_JELLYFIN", "JELLYFIN_API_KEY", "JELLYFIN_URL", "jellyfin")]:
        if get_b(svc[0]):
            data = emby_api_get("/Sessions", CONF[svc[1]], CONF[svc[2]])
            if data:
                for s in data:
                    p = s.get('NowPlayingItem', {}).get('Path')
                    if p: active_items[p] = {'service': svc[3], 'id': s['NowPlayingItem'].get('Id'), 'user': s.get('UserId')}
    return active_items

def check_is_watched(session_data):
    if not session_data: return False
    service = session_data.get('service')
    if service == 'plex':
        r_key = session_data.get('id')
        data = plex_api_get(f"/library/metadata/{r_key}")
        if data and 'MediaContainer' in data and 'Metadata' in data['MediaContainer']:
            meta = data['MediaContainer']['Metadata'][0]
            if 'viewCount' in meta and meta['viewCount'] > 0: return True
    elif service in ['emby', 'jellyfin']:
        item_id, user_id = session_data.get('id'), session_data.get('user')
        url = CONF["EMBY_URL"] if service == 'emby' else CONF["JELLYFIN_URL"]
        key = CONF["EMBY_API_KEY"] if service == 'emby' else CONF["JELLYFIN_API_KEY"]
        if item_id and user_id:
            data = emby_api_get(f"/Users/{user_id}/Items/{item_id}", key, url)
            if data and 'UserData' in data: return data['UserData'].get('Played', False)
    return False

def translate_path(docker_path):
    clean = docker_path.replace('\\', '/')
    ARRAY_ROOT = CONF["ARRAY_ROOT"]
    for dp, hp in parsed_docker_mappings.items():
        if clean.startswith(dp):
            rel = clean[len(dp):].lstrip('/')
            if hp.startswith(ARRAY_ROOT): return os.path.join(hp, rel).replace('//', '/')
            else: return os.path.join(ARRAY_ROOT, hp.lstrip('/'), rel).replace('//', '/')
    return clean

def cache_file_if_needed(source_path):
    rel_path = source_path.replace(CONF["ARRAY_ROOT"], "").lstrip("/")
    if not rel_path: return
    dest_path = os.path.join(CONF["CACHE_ROOT"], rel_path)
    if os.path.exists(dest_path) and os.path.getsize(source_path) == os.path.getsize(dest_path): return
    log_info(f"[Copy] -> {os.path.basename(source_path)}")
    try:
        ensure_directory_structure_mirror(dest_path)
        subprocess.run(["rsync", "-a", source_path, dest_path], check=True, stdout=subprocess.DEVNULL)
        clone_rights_from_disk(dest_path)
    except Exception as e: log_info(f"[Error] Copy: {e}")

def handle_media(src):
    match = re.search(r"[sS]\d+[eE](\d+)", os.path.basename(src))
    ep = int(match.group(1)) if match else None
    if ep is not None:
        folder = os.path.dirname(src)
        if os.path.exists(folder):
            for f in sorted(os.listdir(folder)):
                m = re.search(r"[sS]\d+[eE](\d+)", f)
                f_ep = int(m.group(1)) if m else None
                if f_ep is not None and f_ep >= ep: cache_file_if_needed(os.path.join(folder, f))
    else:
        folder, stem = os.path.dirname(src), os.path.splitext(os.path.basename(src))[0]
        if os.path.exists(folder):
            for f in os.listdir(folder):
                if f.startswith(stem): cache_file_if_needed(os.path.join(folder, f))

if __name__ == "__main__":
    lock_file = open(LOCK_FILE_PATH, 'w')
    try: fcntl.lockf(lock_file, fcntl.LOCK_EX | fcntl.LOCK_NB)
    except: sys.exit(0)
    load_plugin_config()
    log_info("Dienst gestartet. Warte auf Streams...")
    check_connection()
    last_sessions = set()
    while True:
        try:
            active_sessions = get_active_sessions()
            curr_paths = set(active_sessions.keys())
            for p in curr_paths - last_sessions: log_info(f"[Stream] Aktiv: {os.path.basename(p)}")
            for dp in active_sessions:
                rp = translate_path(dp)
                if rp.startswith(CONF["ARRAY_ROOT"]):
                    if rp not in stream_start_times: stream_start_times[rp] = time.time()
                    if time.time() - stream_start_times[rp] >= get_i("COPY_DELAY"): handle_media(rp)
            for p in list(stream_start_times.keys()):
                if p not in [translate_path(x) for x in curr_paths]: del stream_start_times[p]
            last_sessions = curr_paths
        except Exception as e: log_info(f"[Error] Loop: {e}")
        time.sleep(get_i("CHECK_INTERVAL"))
]]>
</INLINE>
</FILE>

<FILE Name="/usr/local/emhttp/plugins/&name;/scripts/rc.plex_to_cache">
<INLINE>
<![CDATA[
#!/bin/bash
PYTHON_SCRIPT="/usr/local/emhttp/plugins/plex_to_cache/scripts/plex_to_cache.py"
PID_FILE="/var/run/plex_to_cache.pid"
LOG_FILE="/var/log/plex_to_cache.log"
start() {
    if [ -f "$PID_FILE" ] && ps -p $(cat "$PID_FILE") > /dev/null; then return; fi
    touch "$LOG_FILE" && chmod 666 "$LOG_FILE"
    nohup python3 "$PYTHON_SCRIPT" >> "$LOG_FILE" 2>&1 &
    echo $! > "$PID_FILE"
}
stop() {
    if [ -f "$PID_FILE" ]; then kill -9 $(cat "$PID_FILE") 2>/dev/null; rm "$PID_FILE"; fi
    pkill -f plex_to_cache.py 2>/dev/null
}
case "$1" in
    start) start ;; 
    stop) stop ;; 
    restart) stop; sleep 2; start ;; 
esac
]]>
</INLINE>
</FILE>

<FILE Run="/bin/bash">
<INLINE>
<![CDATA[
# Pip & Requests installation
if ! python3 -c "import requests" 2>/dev/null; then
    if ! command -v pip3 >/dev/null 2>&1;
then
        echo "Pip fehlt. Installiere..."
        curl -s https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py
        python3 /tmp/get-pip.py >/dev/null 2>&1
    fi
    pip3 install requests >/dev/null 2>&1
fi

pkill -9 -f plex_to_cache.py 2>/dev/null
chmod +x /usr/local/emhttp/plugins/plex_to_cache/scripts/rc.plex_to_cache
chmod +x /usr/local/emhttp/plugins/plex_to_cache/scripts/plex_to_cache.py
mkdir -p /boot/config/plugins/plex_to_cache
touch /var/log/plex_to_cache.log
chmod 666 /var/log/plex_to_cache.log
/usr/local/emhttp/plugins/plex_to_cache/scripts/rc.plex_to_cache restart
echo "Update v2025.12.30u installiert."
]]>
</INLINE>
</FILE>

</PLUGIN>
